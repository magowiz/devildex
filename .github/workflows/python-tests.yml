# .github/workflows/python-tests.yml
name: Python Tests

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]

permissions:
  contents: read

jobs:
  test:
    # Non eseguire questo job se il messaggio di commit contiene [lint]
    # La condizione 'if' è stata rimossa perché causava problemi con
    # gli eventi 'pull_request'. La reintrodurremo in modo più robusto
    # una volta che il workflow base funziona.

    runs-on: ubuntu-latest

    # Il Jenkinsfile usa un container Docker. Qui usiamo un runner standard
    # e installiamo le dipendenze. È più semplice e veloce per iniziare.
    # Se il tuo Dockerfile ha dipendenze di sistema complesse, puoi aggiungere
    # un blocco 'container:' qui per usare un'immagine specifica.

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python 3.13
      uses: actions/setup-python@v5
      with:
        python-version: '3.13'

    - name: Install Poetry
      run: pip install poetry

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libgtk-3-dev \
          libwebkit2gtk-4.1-dev \
          libxtst-dev \
          xvfb \
          bzr

    - name: Configure Poetry and install dependencies
      run: |
        poetry config virtualenvs.in-project true
        poetry install --with test

    - name: Setup Bazaar and Launchpad credentials
      env:
        # Crea un segreto nel tuo repository GitHub chiamato LAUNCHPAD_ID_CONF_FILE
        # con il contenuto del tuo file di configurazione.
        LAUNCHPAD_CONFIG_FILE_CONTENT: ${{ secrets.LAUNCHPAD_ID_CONF_FILE }}
      run: |
        mkdir -p ~/.bazaar/
        echo "${LAUNCHPAD_CONFIG_FILE_CONTENT}" > ~/.bazaar/launchpad.conf
        echo "Launchpad config file created."

    - name: Run tests with Xvfb
      # Il Jenkinsfile usa una funzione custom 'pyTestXvfb'.
      # Questo è l'equivalente standard su Linux.
      # I runner di GitHub hanno Xvfb preinstallato.
      # I flag --html e --cov generano i report che poi carichiamo come artefatti.
      run: |
        xvfb-run poetry run pytest --verbose \
          --cov=src \
          --cov-report=xml \
          --cov-report=html:coverage_report \
          --html=test_report/index.html \
          --junitxml=test-results.xml

    - name: Upload Test Report (HTML)
      # Esegui sempre questo step, anche se i test falliscono, per poter vedere il report.
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-report-html
        path: test_report/

    - name: Upload Coverage Report (HTML)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report-html
        path: coverage_report/

    - name: Upload Screenshots on failure
      if: failure() # Esegui solo se i test falliscono
      uses: actions/upload-artifact@v4
      with:
        name: test-screenshots
        path: screenshots/
        if-no-files-found: ignore # Non fallire se non ci sono screenshot

    - name: Upload Coverage Report (XML for SonarQube)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: coverage-xml
        path: coverage.xml
        if-no-files-found: ignore

    - name: Upload Test Results (XML for SonarQube)
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-xml
        path: test-results.xml
        if-no-files-found: ignore