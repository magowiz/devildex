import configparser  # <-- Importa configparser
import os
import re  # Assicurati sia importato all'inizio del file
import shutil
import subprocess
import sys
from urllib.parse import urlparse

import requests
from info import VERSION

# --- Leggi la configurazione ---
config = configparser.ConfigParser()
config_file = "devildex_config.ini"
default_theme = "furo"  # Default se il file o la chiave mancano
default_banner = "Generated by DevilDex"
try:
    if not config.read(config_file, encoding="utf-8"):
        print(
            f"Avviso: File di configurazione '{config_file}' non trovato. "
            "Uso i valori di default."
        )
        custom_theme = default_theme
        custom_banner = default_banner
        # custom_css = None # Esempio per CSS opzionale
    else:
        custom_theme = config.get("customization", "theme_name", fallback=default_theme)
        custom_banner = config.get(
            "customization", "banner_text", fallback=default_banner
        )
        print(
            f"Configurazione letta da '{config_file}': Tema='{custom_theme}', "
            f"Banner='{custom_banner}'"
        )

except configparser.Error as e:
    print(
        f"Errore nella lettura del file di configurazione '{config_file}': {e}. "
        "Uso i valori di default."
    )
    custom_theme = default_theme
    custom_banner = default_banner


def _write_custom_css(custom_css_path, css_content):
    try:
        with open(custom_css_path, "w", encoding="utf-8") as f:
            f.write(css_content)
        print(
            "  - Creato/Aggiornato CSS personalizzato: "
            f"{os.path.basename(custom_css_path)}"
        )
    except Exception as e:
        print(f"  - Errore scrittura CSS personalizzato {custom_css_path}: {e}")


def _write_conf(conf_updated, conf_py_path, new_conf_content):
    if conf_updated:
        with open(conf_py_path, "w", encoding="utf-8") as f:
            f.write(new_conf_content)
        print("  - Riscritto conf.py con aggiornamenti.")
    else:
        print("  - conf.py non necessitava di modifiche per le personalizzazioni.")


def _fallback_css(current_list_str, css_file_to_add, new_conf_content, match):
    new_list_str = current_list_str.rstrip()[:-1].strip()
    if new_list_str and new_list_str != "[":
        new_list_str += f", '{css_file_to_add}']"
    else:
        new_list_str = f"['{css_file_to_add}']"
        new_conf_content = new_conf_content.replace(
            match.group(0), f"html_css_files = {new_list_str}", 1
        )
    conf_updated = True
    return conf_updated


def _create_template_static(templates_dir, static_dir):
    try:
        os.makedirs(templates_dir, exist_ok=True)
        os.makedirs(static_dir, exist_ok=True)
        print("  - Assicurate directory: _templates, _static")
    except OSError as e:
        print(f"  - Errore creazione directory _templates/_static: {e}")


def _write_override_template(layout_template_path, layout_content):
    try:
        with open(layout_template_path, "w", encoding="utf-8") as f:
            f.write(layout_content)
        print(
            "  - Creato/Aggiornato override template: "
            f"{os.path.basename(layout_template_path)}"
        )
    except Exception as e:
        print(f"  - Errore scrittura override template {layout_template_path}: {e}")


def _update_templates_path_in_conf(new_conf_content, match):
    """Aggiorna la variabile templates_path nel contenuto di conf.py.

    Tenta di aggiungere '_templates' all'inizio della lista esistente
    usando ast.literal_eval, con fallback a concatenazione di stringhe.

    Args:
        new_conf_content (str): Il contenuto attuale (potenzialmente già modificato)
                                del file conf.py.
        match (re.Match): L'oggetto match risultato dalla ricerca del pattern
                          per templates_path.

    Returns:
        tuple(str, bool): Una tupla contenente il contenuto aggiornato di
                          new_conf_content e un booleano che indica se
                          è stata apportata una modifica (True) o meno (False).
    """
    conf_updated = False
    current_list_str = match.group(1)
    if "'_templates'" not in current_list_str:
        try:
            import ast  # Import locale o spostato all'inizio del file se usato altrove

            current_list = ast.literal_eval(current_list_str)
            if isinstance(current_list, list):
                new_list = ["_templates"] + current_list
                new_list_str_repr = repr(new_list)
                # Sostituisce l'intera riga trovata dal match
                new_conf_content = new_conf_content.replace(
                    match.group(0), f"templates_path = {new_list_str_repr}", 1
                )
                print("  - Prepend '_templates' a templates_path in conf.py")
                conf_updated = True
            else:
                # Questo caso è meno probabile se il regex è corretto,
                # ma gestisce il caso in cui literal_eval non restituisce una lista
                raise ValueError("Il valore parsato per templates_path non è una lista")
        except (ValueError, SyntaxError, ImportError):
            print(
                "  - Avviso: Fallback per templates_path, uso concatenazione stringhe."
            )
            new_list_str = "['_templates'] + " + current_list_str
            new_conf_content = new_conf_content.replace(
                match.group(0), f"templates_path = {new_list_str}", 1
            )
            conf_updated = True

    return new_conf_content, conf_updated


def _update_static_path_in_conf(new_conf_content, match):
    """Aggiorna la variabile html_static_path nel contenuto di conf.py.

    Tenta di aggiungere '_static' alla fine della lista esistente
    usando ast.literal_eval, con fallback a concatenazione di stringhe.

    Args:
        new_conf_content (str): Il contenuto attuale (potenzialmente già modificato)
                                del file conf.py.
        match (re.Match): L'oggetto match risultato dalla ricerca del pattern
                          per html_static_path.

    Returns:
        tuple(str, bool): Una tupla contenente il contenuto aggiornato di
                          new_conf_content e un booleano che indica se
                          è stata apportata una modifica (True) o meno (False).
    """
    conf_updated = False
    current_list_str = match.group(1)
    if "'_static'" not in current_list_str:
        try:
            import ast

            current_list = ast.literal_eval(current_list_str)
            if isinstance(current_list, list):
                current_list.append("_static")
                new_list_str_repr = repr(current_list)
                new_conf_content = new_conf_content.replace(
                    match.group(0), f"html_static_path = {new_list_str_repr}", 1
                )
                print("  - Append '_static' a html_static_path in conf.py")
                conf_updated = True
            else:
                raise ValueError(
                    "Il valore parsato per html_static_path non è una lista"
                )
        except (ValueError, SyntaxError, ImportError):
            print(
                "  - Avviso: Fallback per html_static_path, uso "
                "concatenazione stringhe."
            )
            new_list_str = current_list_str.rstrip()[:-1].strip()
            if new_list_str and new_list_str != "[":  # Se la lista non era vuota
                new_list_str += ", '_static']"
            else:
                new_list_str = "['_static']"
            new_conf_content = new_conf_content.replace(
                match.group(0), f"html_static_path = {new_list_str}", 1
            )
            conf_updated = True

    return new_conf_content, conf_updated


def _update_css_files_in_conf(new_conf_content, match, css_file_to_add):
    """Aggiorna la variabile html_css_files nel contenuto di conf.py.

    Tenta di aggiungere il file CSS specificato alla lista esistente
    usando ast.literal_eval, con fallback a concatenazione di stringhe.

    Args:
        new_conf_content (str): Il contenuto attuale (potenzialmente già modificato)
                                del file conf.py.
        match (re.Match): L'oggetto match risultato dalla ricerca del pattern
                          per html_css_files.
        css_file_to_add (str): Il nome del file CSS da aggiungere (es. 'custom.css').

    Returns:
        tuple(str, bool): Una tupla contenente il contenuto aggiornato di
                          new_conf_content e un booleano che indica se
                          è stata apportata una modifica (True) o meno (False).
    """
    conf_updated = False
    current_list_str = match.group(1)
    if repr(css_file_to_add) not in current_list_str:
        try:
            import ast

            current_list = ast.literal_eval(current_list_str)
            if isinstance(current_list, list):
                current_list.append(css_file_to_add)
                new_list_str_repr = repr(current_list)
                new_conf_content = new_conf_content.replace(
                    match.group(0), f"html_css_files = {new_list_str_repr}", 1
                )
                print(f"  - Append '{css_file_to_add}' a html_css_files in conf.py")
                conf_updated = True
            else:
                raise ValueError("Il valore parsato per html_css_files non è una lista")
        except (ValueError, SyntaxError, ImportError):
            print(
                "  - Avviso: Fallback per html_css_files, uso concatenazione stringhe."
            )
            new_list_str = current_list_str.rstrip()[:-1].strip()
            if new_list_str and new_list_str != "[":  # Se la lista non era vuota
                new_list_str += f", '{css_file_to_add}']"
            else:
                new_list_str = f"['{css_file_to_add}']"
            new_conf_content = new_conf_content.replace(
                match.group(0), f"html_css_files = {new_list_str}", 1
            )
            conf_updated = True

    return new_conf_content, conf_updated


def _update_theme_in_conf(conf_content, theme_name):
    """Aggiorna o aggiunge la variabile html_theme nel contenuto di conf.py.

    Args:
        conf_content (str): Il contenuto attuale del file conf.py.
        theme_name (str): Il nome del tema Sphinx desiderato.

    Returns:
        tuple(str, bool): Una tupla contenente il nuovo contenuto di conf.py
                          e un booleano che indica se è stata apportata
                          una modifica (True) o meno (False).
    """
    conf_updated = False
    new_conf_content = conf_content
    theme_pattern = re.compile(r"^\s*html_theme\s*=\s*['\"].*['\"]", re.MULTILINE)
    target_theme_line = f"html_theme = '{theme_name}'"

    match = theme_pattern.search(new_conf_content)
    if match:
        old_theme_line = match.group(0)
        if old_theme_line != target_theme_line:
            new_conf_content = theme_pattern.sub(
                target_theme_line, new_conf_content, count=1
            )
            print(f"  - Aggiornato html_theme -> '{theme_name}' in conf.py")
            conf_updated = True
    else:
        new_conf_content += f"\n{target_theme_line}\n"
        print(f"  - Aggiunto html_theme = '{theme_name}' a conf.py")
        conf_updated = True

    return new_conf_content, conf_updated


def apply_devildex_customizations(isolated_source_path, theme_name, banner_text):
    """Applica personalizzazioni DevilDex alla configurazione e ai template Sphinx,
    basandosi sui parametri forniti.

    Args:
        isolated_source_path (str): Percorso alla directory dei sorgenti doc isolata.
        theme_name (str): Nome del tema Sphinx da utilizzare.
        banner_text (str): Testo da visualizzare nel banner.
    """
    print(
        "\nApplying DevilDex customizations (Theme: "
        f"{theme_name}, Banner: '{banner_text}')..."
    )
    conf_py_path = os.path.join(isolated_source_path, "conf.py")
    templates_dir = os.path.join(isolated_source_path, "_templates")
    static_dir = os.path.join(isolated_source_path, "_static")
    layout_template_path = os.path.join(templates_dir, "layout.html")
    custom_css_path = os.path.join(static_dir, "custom.css")
    _create_template_static(templates_dir, static_dir)
    final_banner = banner_text.format(version=VERSION)
    layout_content = f"""\
    {{% extends "!layout.html" %}}
    {{% block relbar1 %}}
        <div class="devildex-banner">
            {final_banner}
        </div>
        {{{{ super() }}}}
    {{% endblock %}}
    """
    _write_override_template(layout_template_path, layout_content)

    css_content = """\
    /* Stili personalizzati per DevilDex */
    .devildex-banner {
        /* Stile visuale del banner */
        background-color: #eee;
        padding: 6px 10px; /* Padding orizzontale e verticale */
        text-align: center;
        font-size: 0.9em;
        border-bottom: 1px solid #ccc;
        color: #555;
        margin-bottom: 15px; /* Spazio sotto il banner dopo che è stato spostato */
        box-sizing: border-box;
        width: 100%; /* Occupa tutta la larghezza del contenitore */
    }

    /* Rimuovi eventuale padding aggiunto precedentemente al body */
    body > .document {
        padding-top: 0;
    }
    """
    _write_custom_css(custom_css_path, css_content)
    try:
        with open(conf_py_path, "r", encoding="utf-8") as f:
            original_conf_content = f.read()
        new_conf_content = original_conf_content

        conf_updated = False

        new_conf_content, theme_updated = _update_theme_in_conf(
            new_conf_content, theme_name
        )
        if theme_updated:
            conf_updated = True

        templates_pattern = re.compile(
            r"^\s*templates_path\s*=\s*(\[.*?\])", re.MULTILINE | re.DOTALL
        )
        match = templates_pattern.search(new_conf_content)
        if match:
            new_conf_content, updated_by_template = _update_templates_path_in_conf(
                new_conf_content, match
            )
            if updated_by_template:
                conf_updated = True

        else:
            new_conf_content += "\ntemplates_path = ['_templates']\n"
            print("  - Aggiunto templates_path = ['_templates'] a conf.py")
            conf_updated = True

        static_pattern = re.compile(
            r"^\s*html_static_path\s*=\s*(\[.*?\])", re.MULTILINE | re.DOTALL
        )
        match = static_pattern.search(new_conf_content)
        if match:
            new_conf_content, updated_by_static = _update_static_path_in_conf(
                new_conf_content, match
            )
            if updated_by_static:
                conf_updated = True
        else:
            new_conf_content += "\nhtml_static_path = ['_static']\n"
            print("  - Aggiunto html_static_path = ['_static'] a conf.py")
            conf_updated = True

        css_pattern = re.compile(
            r"^\s*html_css_files\s*=\s*(\[.*?\])", re.MULTILINE | re.DOTALL
        )
        match = css_pattern.search(new_conf_content)
        css_file_to_add = "custom.css"  # Nome fisso
        if match:
            new_conf_content, updated_by_static = _update_static_path_in_conf(
                new_conf_content, match
            )
            if updated_by_static:
                conf_updated = True
        else:
            new_conf_content += f"\nhtml_css_files = ['{css_file_to_add}']\n"
            print(f"  - Aggiunto html_css_files = ['{css_file_to_add}'] a conf.py")
            conf_updated = True
        _write_conf(conf_updated, conf_py_path, new_conf_content)
    except Exception as e:
        print(f"  - Errore durante la modifica di conf.py {conf_py_path}: {e}")

    print("Personalizzazioni DevilDex applicate.")


def patch_include_directives(doc_source_path):
    """Patches relative include directives in specific Markdown files.
    Changes `{include} ../FILE` to `{include} /FILE` (absolute from source dir).
    """
    print(f"\nPatching include directives in {doc_source_path}...")
    files_to_patch = {
        "authors.md": "../AUTHORS.md",
        "change_log.md": "../CHANGES.md",
        "license.md": "../LICENSE",
    }
    patched_count = 0

    for md_file, old_include_path in files_to_patch.items():
        file_path = os.path.join(doc_source_path, md_file)
        if os.path.exists(file_path):
            try:
                with open(file_path, "r+", encoding="utf-8") as f:
                    content = f.read()
                    old_directive = f"{{include}} {old_include_path}"
                    new_filename = os.path.basename(old_include_path)
                    new_directive = f"{{include}} /{new_filename}"

                    if old_directive in content:
                        new_content = content.replace(old_directive, new_directive)
                        f.seek(0)
                        f.write(new_content)
                        f.truncate()
                        print(
                            f"  - Patchato {md_file}: '{old_directive}' -> "
                            f"'{new_directive}'"
                        )
                        patched_count += 1
                    else:
                        print(
                            f"  - Direttiva '{old_directive}' non trovata in "
                            f"{md_file}, nessun patch."
                        )

            except Exception as patch_err:
                print(f"  - Errore durante il patching di {md_file}: {patch_err}")
        else:
            print(f"  - File {md_file} non trovato in {doc_source_path}, salto patch.")

    if patched_count > 0:
        print("Patching completato.")
    else:
        print("Nessun file patchato (o direttive non trovate).")


def _find_dir(repo_path, potential_doc_dirs):
    found_doc_path = None
    for doc_dir_name in potential_doc_dirs:
        current_path = os.path.join(repo_path, doc_dir_name)
        if os.path.isdir(current_path) and os.path.exists(
            os.path.join(current_path, "conf.py")
        ):
            found_doc_path = current_path
            print(
                "Trovata directory sorgente documentazione con conf.py: "
                f"{found_doc_path}"
            )
            break
        elif os.path.isdir(current_path):
            print(
                f"Trovata directory '{current_path}', ma senza conf.py. "
                "Continuo la ricerca..."
            )
    return found_doc_path


def _clean_isolated_doc_path(isolated_doc_path):
    if os.path.exists(isolated_doc_path):
        print(
            "Rimuovo la directory dei sorgenti isolati "
            f"esistente: '{isolated_doc_path}'"
        )
        try:
            shutil.rmtree(isolated_doc_path)
        except Exception as e:
            print(f"Errore durante la rimozione della directory esistente: {e}")
            return None
    return True


def _copy_src_doc(repo_path, isolated_doc_path, found_doc_path):
    if (
        os.path.exists(os.path.join(found_doc_path, "conf.py"))
        or found_doc_path == repo_path
    ):
        shutil.copytree(
            found_doc_path, isolated_doc_path, ignore=shutil.ignore_patterns(".git")
        )
        print("Copia della directory sorgente principale completata.")
    else:
        print(
            f"Errore: conf.py non trovato nel percorso selezionato '{found_doc_path}' "
            "durante la copia."
        )
        return None
    return True


def _copy_common_files(common_root_files, repo_path, isolated_doc_path):
    copied_root_files_count = 0
    for filename in common_root_files:
        src_file = os.path.join(repo_path, filename)
        dst_file = os.path.join(isolated_doc_path, filename)
        if os.path.exists(src_file):
            try:
                shutil.copy2(src_file, dst_file)
                print(f"  - Copiato: {filename}")
                copied_root_files_count += 1
            except Exception as copy_err:
                print(f"  - Errore durante la copia di {filename}: {copy_err}")
        else:
            print(
                f"  - File root '{filename}' non trovato in {repo_path}, non copiato."
            )
    return copied_root_files_count


def find_and_copy_doc_source(repo_path, output_base_dir, project_slug):
    """Cerca le directory sorgente della documentazione all'interno di una
    repository clonata
    e copia la prima trovata in una cartella di output dedicata, includendo
    file specifici dalla root.

    Args:
        repo_path (str): Il percorso locale alla repository clonata.
        output_base_dir (str): La directory base dove salvare i sorgenti isolati.
        project_slug (str): Lo slug del progetto, usato per nominare
            la cartella di output.

    Returns:
        str: Il percorso alla directory dei sorgenti di documentazione isolati,
            o None se non trovati/copiati.
    """
    print(f"\nRicerca directory sorgente documentazione in: {repo_path}")

    potential_doc_dirs = ["docs", "doc", "Doc"]

    found_doc_path = _find_dir(repo_path, potential_doc_dirs)

    if not found_doc_path and os.path.exists(os.path.join(repo_path, "conf.py")):
        found_doc_path = repo_path
        print(f"Trovato conf.py nella root della repository: {found_doc_path}")

    if not found_doc_path:
        print("Nessuna directory sorgente documentazione con conf.py trovata.")
        return None

    isolated_doc_dir_name = f"{project_slug}_doc_source"
    isolated_doc_path = os.path.join(output_base_dir, isolated_doc_dir_name)

    if not _clean_isolated_doc_path(isolated_doc_path):
        return None

    print(
        f"Copio i sorgenti della documentazione da '{found_doc_path}' a "
        f"'{isolated_doc_path}'"
    )
    try:
        if not _copy_src_doc(repo_path, isolated_doc_path, found_doc_path):
            return None
        common_root_files = ["AUTHORS.md", "CHANGES.md", "LICENSE"]
        print("Cerco e copio file comuni dalla root del repository...")
        copied_root_files_count = _copy_common_files(
            common_root_files, repo_path, isolated_doc_path
        )
        if copied_root_files_count == len(common_root_files):
            print(
                f"Copiati {copied_root_files_count} file "
                "aggiuntivi richiesti dalla root."
            )
        elif copied_root_files_count > 0:
            print(
                f"Copiati {copied_root_files_count}/{len(common_root_files)} "
                "file aggiuntivi richiesti dalla root."
            )
        else:
            print(
                "Avviso: Nessun file comune aggiuntivo richiesto trovato "
                "o copiato dalla root."
            )

        return isolated_doc_path

    except Exception as e:
        print(f"Errore durante la copia dei sorgenti della documentazione: {e}")
        return None


def _sphinx_run(isolated_source_path, final_output_dir):
    sphinx_build_command = [
        sys.executable,
        "-m",
        "sphinx",
        "-b",
        "html",
        "-W",
        isolated_source_path,
        final_output_dir,
    ]

    print(f"Eseguo Sphinx: {' '.join(sphinx_build_command)}")
    try:
        result = subprocess.run(
            sphinx_build_command,
            check=True,
            capture_output=True,
            text=True,
            encoding="utf-8",
        )
        print("Build Sphinx completato con successo.")
        if result.stdout:
            print("--- Output Sphinx (stdout) ---")
            print(result.stdout)
            print("-----------------------------")
        if result.stderr:
            print("--- Output Sphinx (stderr) ---")
            print(result.stderr)
            print("-----------------------------")
        return final_output_dir

    except subprocess.CalledProcessError as e:
        print(f"Errore durante l'esecuzione di sphinx-build (codice {e.returncode}):")
        print(f"Comando: {' '.join(e.cmd)}")
        print("--- Output Sphinx (stdout) ---")
        print(e.stdout)
        print("--- Output Sphinx (stderr) ---")
        print(e.stderr)
        print("-----------------------------")
        return None
    except FileNotFoundError:
        print(f"Errore: Impossibile eseguire '{sys.executable} -m sphinx'.")
        print("Assicurati che Python sia nel PATH e che Sphinx sia installato")
        print("per questo interprete Python (`pip install sphinx`).")
        return None
    except Exception as e:
        print(f"Errore imprevisto durante la build Sphinx: {e}")
        return None


def build_sphinx_docs(isolated_source_path, project_slug, version_identifier):
    """
    Esegue sphinx-build sulla directory dei sorgenti isolati.

    Args:
        isolated_source_path (str): Percorso alla directory contenente
            conf.py e i sorgenti.
        project_slug (str): Slug del progetto per la struttura della directory
            di output.
        version_identifier (str): Identificativo della versione (es. nome branch) per la struttura.

    Returns:
        str: Il percorso alla directory di output della build HTML, o None in caso di fallimento.
    """
    print("\n--- Avvio Build Sphinx ---")
    conf_py_path = os.path.join(isolated_source_path, "conf.py")
    if not os.path.exists(conf_py_path):
        print(
            f"Errore critico: conf.py non trovato in {isolated_source_path} dopo la copia."
        )
        return None

    final_output_dir = os.path.join("docset", project_slug, version_identifier)
    print(f"Directory di output per la build Sphinx HTML: {final_output_dir}")

    try:
        if os.path.exists(final_output_dir):
            print(f"Rimuovo la directory di output esistente: {final_output_dir}")
            shutil.rmtree(final_output_dir)
        os.makedirs(final_output_dir, exist_ok=True)
    except OSError as e:
        print(
            f"Errore nella creazione/pulizia della directory di output {final_output_dir}: {e}"
        )
        return None
    result = _sphinx_run(isolated_source_path, final_output_dir)
    return result


def _cleanup(clone_dir_path):
    if os.path.exists(clone_dir_path):
        print(f"\nElimino la directory della repository clonata: {clone_dir_path}")
        try:
            shutil.rmtree(clone_dir_path)
            print("Eliminazione completata.")
        except Exception as e:
            print(
                f"Errore durante l'eliminazione della repository clonata '{clone_dir_path}': {e}"
            )


def _extract_slug(rtd_url):
    parsed_url = urlparse(rtd_url)
    path_parts = [part for part in parsed_url.path.split("/") if part]
    project_slug = parsed_url.hostname.split(".")[0]
    if project_slug == "readthedocs" and path_parts:
        project_slug = path_parts[0]
    elif not project_slug or project_slug == "readthedocs":
        if path_parts:
            project_slug = path_parts[0]
        else:
            print("Errore: Impossibile dedurre lo slug del progetto dall'URL.")
            return None, None
    return project_slug


def _extract_repo_url_branch(api_project_detail_url, project_slug):
    repo_url = None
    default_branch = "main"

    try:
        response = requests.get(api_project_detail_url)
        response.raise_for_status()
        project_data = response.json()
        repo_data = project_data.get("repository")
        if repo_data:
            repo_url = repo_data.get("url")
        default_branch = project_data.get("default_branch", default_branch)

        if not repo_url:
            print(
                f"Avviso: URL del repository sorgente non trovato per '{project_slug}' tramite API."
            )
        else:
            print(f"Trovato URL repository: {repo_url}")
            print(
                f"Branch di default (usato come version identifier): {default_branch}"
            )

    except requests.exceptions.RequestException as e:
        print(f"Avviso: Errore durante la richiesta API: {e}")
        print("Provo a cercare la repository clonata localmente se esiste già.")
    return default_branch, repo_url


def download_readthedocs_source_and_build(rtd_url):
    """
    Ottiene sorgente RTD, clona, isola i sorgenti doc, esegue Sphinx, e pulisce.

    Args:
        rtd_url (str): L'URL base del progetto Read the Docs (es. https://black.readthedocs.io/).

    Returns:
        tuple(str, str) or tuple(None, None): Percorso sorgenti isolati e percorso build HTML,
                                              o (None, None) in caso di fallimento.
    """
    print("--- Processo Download Sorgente, Build e Pulizia ---")
    print(f"Analizzo l'URL: {rtd_url}")

    project_slug = _extract_slug(rtd_url)
    if not project_slug:
        return None, None

    print(f"Slug del progetto dedotto: {project_slug}")
    api_project_detail_url = f"https://readthedocs.org/api/v3/projects/{project_slug}/"
    print(f"Chiamo l'API per i dettagli del progetto: {api_project_detail_url}")

    default_branch, repo_url = _extract_repo_url_branch(
        api_project_detail_url, project_slug
    )
    base_output_dir = "rtd_source_clones_temp"
    os.makedirs(base_output_dir, exist_ok=True)
    clone_dir_name = f"{project_slug}_repo_{default_branch}"
    clone_dir_path = os.path.join(base_output_dir, clone_dir_name)
    cloned_repo_exists_before = os.path.exists(clone_dir_path)

    if repo_url and not cloned_repo_exists_before:
        print(f"Clono il repository (branch '{default_branch}') in: {clone_dir_path}")
        try:
            subprocess.run(
                [
                    "git",
                    "clone",
                    "--depth",
                    "1",
                    "--branch",
                    default_branch,
                    repo_url,
                    clone_dir_path,
                ],
                check=True,
                capture_output=True,
                text=True,
                encoding="utf-8",
            )
            print("Comando git clone eseguito con successo.")
        except subprocess.CalledProcessError as e:
            print(f"Errore durante l'esecuzione del comando git clone:\n{e.stderr}")
            return None, None
        except FileNotFoundError:
            print(
                "Errore: Il comando 'git' non è stato trovato. Assicurati"
                " che Git sia installato."
            )
            return None, None
    elif not cloned_repo_exists_before:
        print(
            f"Impossibile clonare (URL non disponibile o errore) e "
            f"la directory attesa '{clone_dir_path}' non esiste."
        )
        return None, None
    else:
        print(f"Directory di clonazione attesa '{clone_dir_path}' trovata localmente.")

    isolated_docs_output_dir = "rtd_isolated_doc_sources"
    os.makedirs(isolated_docs_output_dir, exist_ok=True)
    isolated_source_path = find_and_copy_doc_source(
        clone_dir_path, isolated_docs_output_dir, project_slug
    )

    build_output_path = None
    if isolated_source_path:
        patch_include_directives(isolated_source_path)
        apply_devildex_customizations(
            isolated_source_path, theme_name=custom_theme, banner_text=custom_banner
        )

        build_output_path = build_sphinx_docs(
            isolated_source_path, project_slug, default_branch
        )
    else:
        print("Isolamento sorgenti fallito, salto la build Sphinx.")

    _cleanup(clone_dir_path)

    if isolated_source_path and build_output_path:
        print(f"\nSorgenti documentazione isolati in: {isolated_source_path}")
        print(f"Build HTML Sphinx generata in:    {build_output_path}")
        return isolated_source_path, build_output_path
    elif isolated_source_path:
        print(f"\nSorgenti documentazione isolati in: {isolated_source_path}")
        print("Build Sphinx fallita.")
        return isolated_source_path, None
    else:
        print("\nIsolamento sorgenti e build Sphinx falliti.")
        return None, None


print("--- Esecuzione Script v3 (Isola Sorgente + Build Sphinx + Pulizia) ---")

isolated_folder, build_folder = download_readthedocs_source_and_build(
    "https://black.readthedocs.io/"
)

if build_folder:
    print("\nProcesso completato con successo!")
    print(f"  Sorgenti isolati: {isolated_folder}")
    print(f"  Build HTML:       {build_folder}")
elif isolated_folder:
    print("\nProcesso parzialmente completato.")
    print(f"  Sorgenti isolati: {isolated_folder}")
    print("  Build HTML fallita.")
else:
    print("\nProcesso fallito.")
print("-" * 30)
