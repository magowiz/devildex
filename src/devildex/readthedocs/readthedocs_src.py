"""readthedocs source handling module."""

import ast
import configparser
import logging
import os
import re
import shutil
import subprocess
from pathlib import Path

import requests

from devildex.info import PROJECT_ROOT, VERSION
from devildex.utils.venv_cm import IsolatedVenvManager
from devildex.utils.venv_utils import (
    execute_command,
    install_project_and_dependencies_in_venv,
)

logger = logging.getLogger(__name__)
if not logger.hasHandlers():
    logging.basicConfig(
        level=logging.INFO, format="%(name)s - %(levelname)s - %(message)s"
    )

config = configparser.ConfigParser()
config_file = PROJECT_ROOT / "devildex_config.ini"
DEFAULT_THEME = "furo"
DEFAULT_BANNER = "Generated by DevilDex"
try:
    if not config.read(config_file, encoding="utf-8"):
        print(
            f"Warning: configuration File  '{config_file}' not found. "
            "Using default values."
        )
        CUSTOM_THEME = DEFAULT_THEME
        CUSTOM_BANNER = DEFAULT_BANNER
    else:
        custom_theme = config.get("customization", "theme_name", fallback=DEFAULT_THEME)
        custom_banner = config.get(
            "customization", "banner_text", fallback=DEFAULT_BANNER
        )
        print(
            f"Configuration read from '{config_file}': Theme='{custom_theme}', "
            f"Banner='{custom_banner}'"
        )

except configparser.Error as exc:
    print(
        f"Error reading configuration file '{config_file}': {exc}. "
        "Using default values."
    )


def _write_custom_css(custom_css_path, css_content):
    try:
        with open(custom_css_path, "w", encoding="utf-8") as f:
            f.write(css_content)
        print(
            "  - Created/Updated customized CSS: "
            f"{os.path.basename(custom_css_path)}"
        )
    except Exception as e:
        print(f"  - Error writing customized CSS {custom_css_path}: {e}")


def _write_conf(conf_updated, conf_py_path, new_conf_content):
    if conf_updated:
        with open(conf_py_path, "w", encoding="utf-8") as f:
            f.write(new_conf_content)
        print("  - conf.py rewritten with updates.")
    else:
        print("  - conf.py did not need modifications for customizations.")


def _fallback_css(current_list_str, css_file_to_add, new_conf_content, match):
    new_list_str = current_list_str.rstrip()[:-1].strip()
    if new_list_str and new_list_str != "[":
        new_list_str += f", '{css_file_to_add}']"
    else:
        new_list_str = f"['{css_file_to_add}']"
        new_conf_content = new_conf_content.replace(
            match.group(0), f"html_css_files = {new_list_str}", 1
        )
    conf_updated = True
    return conf_updated


def _create_template_static(templates_dir, static_dir):
    try:
        os.makedirs(templates_dir, exist_ok=True)
        os.makedirs(static_dir, exist_ok=True)
        print("  - Created directory: _templates, _static")
    except OSError as e:
        print(f"  - Error creating directory _templates/_static: {e}")


def _write_override_template(layout_template_path, layout_content):
    try:
        with open(layout_template_path, "w", encoding="utf-8") as f:
            f.write(layout_content)
        print(
            "  - Created/Updated override template: "
            f"{os.path.basename(layout_template_path)}"
        )
    except Exception as e:
        print(f"  - Error writing override template {layout_template_path}: {e}")


def _update_templates_path_in_conf(new_conf_content, match):
    """Update templates_path variable in conf.py content.

    Tries to add '_templates' at the beginning of existing list
    using ast.literal_eval, con fallback a concatenating di strings.

    Args:
        new_conf_content (str): current content (potentially already modified)
                                del file conf.py.
        match (re.Match): Match object resulting from search pattern
                          for templates_path.

    Returns:
        tuple(str, bool): tuple containing up-to-date content of
                          new_conf_content and a boolean that tells if
                          a modification has been made (True) or not (False).
    """
    conf_updated = False
    current_list_str = match.group(1)
    if "'_templates'" not in current_list_str:
        try:

            current_list = ast.literal_eval(current_list_str)
            if isinstance(current_list, list):
                new_list = ["_templates"] + current_list
                new_list_str_repr = repr(new_list)
                new_conf_content = new_conf_content.replace(
                    match.group(0), f"templates_path = {new_list_str_repr}", 1
                )
                print("  - Prepend '_templates' a templates_path in conf.py")
                conf_updated = True
            else:
                raise ValueError("parsed value for templates_path is not a list")
        except (ValueError, SyntaxError, ImportError):
            print(
                "  - Warning: Fallback per templates_path, uso concatenating strings."
            )
            new_list_str = "['_templates'] + " + current_list_str
            new_conf_content = new_conf_content.replace(
                match.group(0), f"templates_path = {new_list_str}", 1
            )
            conf_updated = True

    return new_conf_content, conf_updated


def _update_static_path_in_conf(new_conf_content, match):
    """Updates la variable html_static_path nel content di conf.py.

    Try to add '_static' alla fine della lista existing
    using ast.literal_eval, con fallback a concatenating di strings.

    Args:
        new_conf_content (str): Il current content (potentially already modified)
                                del file conf.py.
        match (re.Match): Match object match resulting from searching pattern
                          for html_static_path.

    Returns:
        tuple(str, bool): A tuple containing up-to-date content of
                          new_conf_content and a bool that tells if
                          there was a modification (True) or not (False).
    """
    conf_updated = False
    current_list_str = match.group(1)
    if "'_static'" not in current_list_str:
        try:

            current_list = ast.literal_eval(current_list_str)
            if isinstance(current_list, list):
                current_list.append("_static")
                new_list_str_repr = repr(current_list)
                new_conf_content = new_conf_content.replace(
                    match.group(0), f"html_static_path = {new_list_str_repr}", 1
                )
                print("  - Append '_static' a html_static_path in conf.py")
                conf_updated = True
            else:
                raise ValueError("parsed value for html_static_path is not a list")
        except (ValueError, SyntaxError, ImportError):
            print(
                "  - Warning: Fallback per html_static_path, uso "
                "concatenating strings."
            )
            new_list_str = current_list_str.rstrip()[:-1].strip()
            if new_list_str and new_list_str != "[":
                new_list_str += ", '_static']"
            else:
                new_list_str = "['_static']"
            new_conf_content = new_conf_content.replace(
                match.group(0), f"html_static_path = {new_list_str}", 1
            )
            conf_updated = True

    return new_conf_content, conf_updated


def _update_css_files_in_conf(new_conf_content, match, css_file_to_add):
    """Update html_css_files variable in conf.py content.

    Tenta di add il specified CSS file to existing list
    using ast.literal_eval, con fallback a concatenating di strings.

    Args:
        new_conf_content (str): current content (potentially already modified)
                                del file conf.py.
        match (re.Match): match object resulting from pattern search for
                          html_css_files.
        css_file_to_add (str): Il nome del file CSS da add (ex. 'custom.css').

    Returns:
        tuple(str, bool): A tuple containing il up-to-date content of
                          new_conf_content and a bool that tells if
                          a modification occurred (True) or not (False).
    """
    conf_updated = False
    current_list_str = match.group(1)
    if repr(css_file_to_add) not in current_list_str:
        try:

            current_list = ast.literal_eval(current_list_str)
            if isinstance(current_list, list):
                current_list.append(css_file_to_add)
                new_list_str_repr = repr(current_list)
                new_conf_content = new_conf_content.replace(
                    match.group(0), f"html_css_files = {new_list_str_repr}", 1
                )
                print(f"  - Append '{css_file_to_add}' a html_css_files in conf.py")
                conf_updated = True
            else:
                raise ValueError("parsed value for html_css_files is not a list")
        except (ValueError, SyntaxError, ImportError):
            print(
                "  - Warning: Fallback per html_css_files, uso concatenating strings."
            )
            new_list_str = current_list_str.rstrip()[:-1].strip()
            if new_list_str and new_list_str != "[":
                new_list_str += f", '{css_file_to_add}']"
            else:
                new_list_str = f"['{css_file_to_add}']"
            new_conf_content = new_conf_content.replace(
                match.group(0), f"html_css_files = {new_list_str}", 1
            )
            conf_updated = True

    return new_conf_content, conf_updated


def _update_theme_in_conf(conf_content, theme_name):
    """Update or add html_theme variable in conf.py content.

    Args:
        conf_content (str): current content del file conf.py.
        theme_name (str): desired Sphinx theme name.

    Returns:
        tuple(str, bool): A tuple containing conf.py new content
                          and a bool that tells if
                          a modification was made (True) or not (False).
    """
    return conf_content, True
    conf_updated = False
    new_conf_content = conf_content
    theme_pattern = re.compile(r"^\s*html_theme\s*=\s*['\"].*['\"]", re.MULTILINE)
    target_theme_line = f"html_theme = '{theme_name}'"

    match = theme_pattern.search(new_conf_content)
    if match:
        old_theme_line = match.group(0)
        if old_theme_line != target_theme_line:
            new_conf_content = theme_pattern.sub(
                target_theme_line, new_conf_content, count=1
            )
            print(f"  - Updated html_theme -> '{theme_name}' in conf.py")
            conf_updated = True
    else:
        new_conf_content += f"\n{target_theme_line}\n"
        print(f"  - Added html_theme = '{theme_name}' a conf.py")
        conf_updated = True

    return new_conf_content, conf_updated


def apply_devildex_customizations(isolated_source_path, theme_name, banner_text):
    """Apply DevilDex customizations to conf and template, basing on given parameters.

    Args:
        isolated_source_path (str): Path to isolated sources doc directory.
        theme_name (str): Name of Sphinx theme to use.
        banner_text (str): Testo da view nel banner.
    """
    print(
        "\nApplying DevilDex customizations (Theme: "
        f"{theme_name}, Banner: '{banner_text}')..."
    )
    conf_py_path = os.path.join(isolated_source_path, "conf.py")
    templates_dir = os.path.join(isolated_source_path, "_templates")
    static_dir = os.path.join(isolated_source_path, "_static")
    layout_template_path = os.path.join(templates_dir, "layout.html")
    custom_css_path = os.path.join(static_dir, "custom.css")
    _create_template_static(templates_dir, static_dir)
    final_banner = banner_text.format(version=VERSION)
    layout_content = f"""\
    {{% extends "!layout.html" %}}
    {{% block relbar1 %}}
        <div class="devildex-banner">
            {final_banner}
        </div>
        {{{{ super() }}}}
    {{% endblock %}}
    """
    _write_override_template(layout_template_path, layout_content)

    css_content = """\
    /* customized Styles for DevilDex */
    .devildex-banner {
        /* banner Visual Style */
        background-color: #eee;
        padding: 6px 10px; /* horizontal and vertical Padding */
        text-align: center;
        font-size: 0.9em;
        border-bottom: 1px solid #ccc;
        color: #555;
        margin-bottom: 15px; /* Space under the banner after being moved */
        box-sizing: border-box;
        width: 100%; /* Occupies all container width */
    }

    /* Remove eventual padding added previously to body */
    body > .document {
        padding-top: 0;
    }
    """
    _write_custom_css(custom_css_path, css_content)
    try:
        with open(conf_py_path, "r", encoding="utf-8") as f:
            original_conf_content = f.read()
        new_conf_content = original_conf_content

        conf_updated = False

        new_conf_content, theme_updated = _update_theme_in_conf(
            new_conf_content, theme_name
        )
        if theme_updated:
            conf_updated = True

        templates_pattern = re.compile(
            r"^\s*templates_path\s*=\s*(\[.*?\])", re.MULTILINE | re.DOTALL
        )
        match = templates_pattern.search(new_conf_content)
        if match:
            new_conf_content, updated_by_template = _update_templates_path_in_conf(
                new_conf_content, match
            )
            if updated_by_template:
                conf_updated = True

        else:
            new_conf_content += "\ntemplates_path = ['_templates']\n"
            print("  - Added templates_path = ['_templates'] a conf.py")
            conf_updated = True

        static_pattern = re.compile(
            r"^\s*html_static_path\s*=\s*(\[.*?\])", re.MULTILINE | re.DOTALL
        )
        match = static_pattern.search(new_conf_content)
        if match:
            new_conf_content, updated_by_static = _update_static_path_in_conf(
                new_conf_content, match
            )
            if updated_by_static:
                conf_updated = True
        else:
            new_conf_content += "\nhtml_static_path = ['_static']\n"
            print("  - Added html_static_path = ['_static'] a conf.py")
            conf_updated = True

        css_pattern = re.compile(
            r"^\s*html_css_files\s*=\s*(\[.*?\])", re.MULTILINE | re.DOTALL
        )
        match_css = css_pattern.search(new_conf_content)
        css_file_to_add = "custom.css"
        if match_css:
            new_conf_content, updated_by_css_add = _update_css_files_in_conf(
                new_conf_content, match_css, css_file_to_add
            )
            if updated_by_css_add:
                conf_updated = True
        else:
            new_conf_content += f"\nhtml_css_files = ['{css_file_to_add}']\n"
            print(f"  - Added html_css_files = ['{css_file_to_add}'] a conf.py")
            conf_updated = True
        _write_conf(conf_updated, conf_py_path, new_conf_content)
    except Exception as e:
        print(f"  - Error during modifying conf.py {conf_py_path}: {e}")

    print("DevilDex customizations applied.")


def find_doc_source_in_clone(repo_path):
    """Identifies the documentation source directory within a cloned repository.

    It does NOT copy any files.

    Args:
        repo_path (str): The local path to the cloned repository.

    Returns:
        str: The path to the documentation source directory (containing conf.py),
             or None if not found.
    """
    print(f"\nSearching for documentation source directory in: {repo_path}")
    potential_doc_dirs = ["docs", "doc", "Doc"]

    doc_source_path = _find_doc_dir_in_repo(repo_path, potential_doc_dirs)

    if not doc_source_path:
        print("No documentation source directory with conf.py found in the clone.")
        return None

    print(f"Documentation source directory identified at: {doc_source_path}")
    return doc_source_path


def _find_doc_dir_in_repo(repo_path, potential_doc_dirs):
    """Finds the first potential documentation directory that contains a conf.py file.

    Also checks the repository root if no specific doc directory is found.

    Args:
        repo_path (str): The local path to the cloned repository.
        potential_doc_dirs (list): A list of potential directory names
                                   for documentation (e.g., ["docs", "doc"]).

    Returns:
        str: The path to the documentation source directory (containing conf.py),
             or None if not found.
    """
    for doc_dir_name in potential_doc_dirs:
        current_path = os.path.join(repo_path, doc_dir_name)
        if os.path.isdir(current_path) and os.path.exists(
            os.path.join(current_path, "conf.py")
        ):
            print(
                "Found documentation source directory with conf.py: " f"{current_path}"
            )
            return current_path
        if os.path.isdir(current_path):
            print(
                f"Found directory '{current_path}', but no conf.py. "
                "Continuing search..."
            )

    if os.path.exists(os.path.join(repo_path, "conf.py")):
        print(f"Found conf.py in the repository root: {repo_path}")
        return repo_path

    print(
        f"Fallback: Searching for conf.py recursively in the entire repository: {repo_path}..."
    )
    for root, dirs, files in os.walk(repo_path):
        dirs[:] = [
            d
            for d in dirs
            if d
            not in [
                ".git",
                ".hg",
                ".svn",
                "venv",
                ".venv",
                "env",
                "__pycache__",
                "node_modules",
                "build",
                "dist",
                "docs/_build",
                "site",
            ]
        ]
        if "conf.py" in files:
            conf_file_path = os.path.join(root, "conf.py")
            doc_source_dir = root
            print(
                "Found conf.py via full recursive search at: "
                f"{conf_file_path} (source directory: {doc_source_dir})"
            )
            return doc_source_dir

    return None


def build_sphinx_docs(
    isolated_source_path: str,
    project_slug: str,
    version_identifier: str,
    original_clone_dir_path: str,
) -> str | None:
    """Execute sphinx-build in a temporary, isolated virtual environment."""
    logger.info(
        "\n--- Starting Isolated Sphinx Build for %s v%s ---",
        project_slug,
        version_identifier,
    )
    source_dir_path = Path(isolated_source_path)
    clone_root_path = Path(original_clone_dir_path)

    conf_py_file = source_dir_path / "conf.py"
    if not conf_py_file.exists():
        logger.error("Critical Error: conf.py not found in %s.", source_dir_path)
        return None

    doc_requirements_file: Path | None = None
    candidate_req_paths = [
        source_dir_path / "requirements.txt",
        source_dir_path.parent / "requirements.txt",
        clone_root_path / "doc-requirements.txt",
        clone_root_path / "docs-requirements.txt",
        clone_root_path / "dev-requirements.txt",
        clone_root_path / "requirements-doc.txt",
        clone_root_path / "requirements-docs.txt",
        clone_root_path / "requirements-dev.txt",
        clone_root_path / "requirements.txt",
        clone_root_path / "docs" / "requirements.txt",
        clone_root_path / "doc" / "requirements.txt",
        clone_root_path / "requirements" / "docs.txt",
        clone_root_path / "requirements" / "doc.txt",
    ]
    for req_path_candidate in candidate_req_paths:
        if req_path_candidate.exists():
            doc_requirements_file = req_path_candidate
            logger.info(
                "Found documentation requirements file: %s", doc_requirements_file
            )
            break
    if not doc_requirements_file:
        logger.info(
            "No specific 'requirements.txt' found for documentation in common "
            "locations for %s.",
            project_slug,
        )

    project_install_root: Path | None = clone_root_path
    final_output_dir = (
        PROJECT_ROOT / "docset" / project_slug / version_identifier
    ).resolve()

    logger.info("Sphinx HTML output directory: %s", final_output_dir)

    try:
        if final_output_dir.exists():
            logger.info("Removing existing output directory: %s", final_output_dir)
            shutil.rmtree(final_output_dir)
        final_output_dir.mkdir(parents=True, exist_ok=True)
    except OSError as e:
        logger.error(
            "Error creating/cleaning output directory %s: %s", final_output_dir, e
        )
        return None

    build_successful = False
    try:
        with IsolatedVenvManager(
            project_name=f"{project_slug}-{version_identifier}"
        ) as venv:

            install_success = install_project_and_dependencies_in_venv(
                pip_executable=venv.pip_executable,
                project_name=project_slug,
                project_root_for_install=project_install_root,
                doc_requirements_path=doc_requirements_file,
                base_packages_to_install=[
                    "sphinx",
                    "pallets-sphinx-themes",
                    "sphinxcontrib.log-cabinet",
                    "sphinx-tabs",
                ],
            )

            if not install_success:
                logger.error(
                    "CRITICAL: Installation of project/dependencies (including Sphinx) "
                    "for %s FAILED or had critical issues. Aborting Sphinx build.",
                    project_slug,
                )
                return None

            sphinx_command = [
                venv.python_executable,
                "-m",
                "sphinx",
                "-b",
                "html",
                ".",
                str(final_output_dir),
            ]

            logger.info("Executing Sphinx: %s", " ".join(sphinx_command))
            sphinx_env = {"LC_ALL": "C"}
            _, _, returncode = execute_command(
                sphinx_command,
                f"Sphinx build for {project_slug}",
                cwd=source_dir_path,
                env=sphinx_env,
            )

            if returncode == 0:
                logger.info("Sphinx build for %s completed successfully.", project_slug)
                build_successful = True
            else:
                logger.error(
                    "Sphinx build for %s failed. Return code: %s",
                    project_slug,
                    returncode,
                )

    except RuntimeError as e:
        logger.error(
            "Critical error during isolated build setup for %s: %s", project_slug, e
        )
    except Exception as e:
        logger.exception(
            "Unexpected exception during isolated Sphinx build for %s: %s",
            project_slug,
            e,
        )
    finally:
        logger.info("--- Finished Isolated Sphinx Build for %s ---", project_slug)

    return str(final_output_dir) if build_successful else None


def _cleanup(clone_dir_path):
    if os.path.exists(clone_dir_path):
        print(f"\nDeleting repository cloned directory: {clone_dir_path}")
        try:
            shutil.rmtree(clone_dir_path)
            print("Delete completed.")
        except Exception as e:
            print(
                "Error during deleting della repository cloned "
                f"'{clone_dir_path}': {e}"
            )


def _extract_repo_url_branch(api_project_detail_url, project_slug):
    repo_url = None
    default_branch = "main"

    try:
        response = requests.get(api_project_detail_url, timeout=60)
        response.raise_for_status()
        project_data = response.json()
        repo_data = project_data.get("repository")
        if repo_data:
            repo_url = repo_data.get("url")
        default_branch = project_data.get("default_branch", default_branch)

        if not repo_url:
            print(
                "Warning: URL del repository sources non trovato per "
                f"'{project_slug}' using API."
            )
        else:
            print(f"Trovato URL repository: {repo_url}")
            print(f"Branch di default (used come version identifier): {default_branch}")

    except requests.exceptions.RequestException as e:
        print(f"Warning: Error durante la richiesta API: {e}")
        print("Provo a search la repository cloned locally if already exists.")
    return default_branch, repo_url


def run_clone(repo_url, default_branch, clone_dir_path, bzr):
    """Perform a clone for matching vcs."""
    print(f"Cloning repository (branch '{default_branch}') in: {clone_dir_path}")
    fallback_branches = ["master", "main"]
    cmd_git = [
        "git",
        "clone",
        "--depth",
        "1",
        "--branch",
        default_branch,
        repo_url,
        clone_dir_path,
    ]
    cmd_bzr = ["bzr", "branch", repo_url, str(clone_dir_path)]
    try:
        if not bzr:
            result = subprocess.run(
                cmd_git,
                check=False,
                capture_output=True,
                text=True,
                encoding="utf-8",
            )
            if result.returncode != 0:
                for default_branch in fallback_branches:
                    shutil.rmtree(clone_dir_path, ignore_errors=True)
                    result = subprocess.run(
                        [
                            "git",
                            "clone",
                            "--depth",
                            "1",
                            "--branch",
                            default_branch,
                            repo_url,
                            clone_dir_path,
                        ],
                        check=False,
                        capture_output=True,
                        text=True,
                        encoding="utf-8",
                    )
                    if result.returncode == 0:
                        break
        else:
            subprocess.run(
                cmd_bzr,
                check=True,
                capture_output=True,
                text=True,
                encoding="utf-8",
            )
        print("git clone Command executed successfully.")
    except subprocess.CalledProcessError as e:
        print(f"Error during execution of git clone command:\n{e.stderr}")
        return None, None
    except FileNotFoundError:
        print("Error: 'git' command not found. Be sure that Git is installed.")
        return None, None
    return (
        default_branch
        if default_branch and default_branch.lower() != "unknown"
        else "trunk"
    )


def download_readthedocs_source_and_build(
    project_name, project_url, existing_clone_path=None
):
    """Get RTD sources, clone, isolate sources doc, executes Sphinx, and cleans-up.

    Args:
        project_name (str): the name of the project.
        project_url (str): the URL of repository of the project.
        existing_clone_path (str, optional): Percorso to a repository già clonato.
                                             Se fornito, la clonazione viene saltata.
                                             Default a None.


    Returns:
        tuple(str, str) or tuple(None, None): Path isolated sources and build HTML path
                                              o (None, None) in case of failure.
    """
    print("--- Process Source Download, Build e Clean-up ---")
    print(f"Analyzing the URL: {project_url}")

    project_slug = project_name
    if not project_slug:
        return None, None

    print(f"project Slug: {project_slug}")
    api_project_detail_url = f"https://readthedocs.org/api/v3/projects/{project_slug}/"
    print(f"Calling API for project details: {api_project_detail_url}")

    default_branch, repo_url = _extract_repo_url_branch(
        api_project_detail_url, project_slug
    )
    base_output_dir = PROJECT_ROOT / "rtd_source_clones_temp"
    base_output_dir.mkdir(parents=True, exist_ok=True)
    clone_dir_name = f"{project_slug}_repo_{default_branch}"
    clone_dir_path = base_output_dir / clone_dir_name
    cloned_repo_exists_before = os.path.exists(clone_dir_path)
    bzr = False
    if repo_url and repo_url.startswith("lp:"):
        bzr = True
    if repo_url and not cloned_repo_exists_before:
        run_clone_result = run_clone(repo_url, default_branch, clone_dir_path, bzr)
        if isinstance(run_clone_result, tuple) and (
            not run_clone_result[0] or not run_clone_result[1]
        ):
            return run_clone_result
        elif isinstance(run_clone_result, str):
            cloned_repo_exists_before = True
            default_branch = run_clone_result
    if not cloned_repo_exists_before:
        print(
            "Unable to clone (URL not available or error) e "
            f"expected directory '{clone_dir_path}' doesn't exist."
        )
        return None, None
    print(f"expected clone Directory '{clone_dir_path}' found locally.")

    isolated_docs_output_dir = PROJECT_ROOT / "rtd_isolated_doc_sources"
    isolated_docs_output_dir.mkdir(parents=True, exist_ok=True)
    isolated_source_path = find_doc_source_in_clone(clone_dir_path)

    build_output_path = None
    if isolated_source_path:
        apply_devildex_customizations(
            isolated_source_path, theme_name=custom_theme, banner_text=custom_banner
        )

        build_output_path = build_sphinx_docs(
            isolated_source_path, project_slug, default_branch, clone_dir_path
        )
    else:
        print("Isolate sources Failed, skipping Sphinx build.")

    _cleanup(clone_dir_path)

    return _download_handle_result(isolated_source_path, build_output_path)


def _download_handle_result(isolated_source_path, build_output_path):
    if isolated_source_path and build_output_path:
        print(f"\nIsolated source documentation in: {isolated_source_path}")
        print(f"Build HTML Sphinx generata in:    {build_output_path}")
        return isolated_source_path, build_output_path
    if isolated_source_path:
        print(f"\nIsolated Sources documentation in: {isolated_source_path}")
        print("Failed Build Sphinx.")
        return isolated_source_path, None
    print("\nFailed Isolating sources and build Sphinx.")
    return None, None


if __name__ == "__main__":
    PROJECT_NAME_EXAMPLE = "black"
    PROJECT_URL_EXAMPLE = "https://github.com/psf/black"
    isolated_folder, build_folder = download_readthedocs_source_and_build(
        project_name=PROJECT_NAME_EXAMPLE, project_url=PROJECT_URL_EXAMPLE
    )
