import ast
import configparser
import os
import re
import shutil
import subprocess
import sys
from urllib.parse import urlparse

import requests
from devildex.info import VERSION

config = configparser.ConfigParser()
config_file = "../../../devildex_config.ini"
default_theme = "furo"
DEFAULT_BANNER = "Generated by DevilDex"
try:
    if not config.read(config_file, encoding="utf-8"):
        print(
            f"Warning: configuration File  '{config_file}' not found. "
            "Using default values."
        )
        custom_theme = default_theme
        custom_banner = DEFAULT_BANNER
    else:
        custom_theme = config.get("customization", "theme_name", fallback=default_theme)
        custom_banner = config.get(
            "customization", "banner_text", fallback=DEFAULT_BANNER
        )
        print(
            f"Configuration read from '{config_file}': Theme='{custom_theme}', "
            f"Banner='{custom_banner}'"
        )

except configparser.Error as exc:
    print(
        f"Error reading configuration file '{config_file}': {exc}. "
        "Using default values."
    )


def _write_custom_css(custom_css_path, css_content):
    try:
        with open(custom_css_path, "w", encoding="utf-8") as f:
            f.write(css_content)
        print(
            "  - Created/Updated customized CSS: "
            f"{os.path.basename(custom_css_path)}"
        )
    except Exception as e:
        print(f"  - Error writing customized CSS {custom_css_path}: {e}")


def _write_conf(conf_updated, conf_py_path, new_conf_content):
    if conf_updated:
        with open(conf_py_path, "w", encoding="utf-8") as f:
            f.write(new_conf_content)
        print("  - conf.py rewritten with updates.")
    else:
        print("  - conf.py did not need modifications for customizations.")


def _fallback_css(current_list_str, css_file_to_add, new_conf_content, match):
    new_list_str = current_list_str.rstrip()[:-1].strip()
    if new_list_str and new_list_str != "[":
        new_list_str += f", '{css_file_to_add}']"
    else:
        new_list_str = f"['{css_file_to_add}']"
        new_conf_content = new_conf_content.replace(
            match.group(0), f"html_css_files = {new_list_str}", 1
        )
    conf_updated = True
    return conf_updated


def _create_template_static(templates_dir, static_dir):
    try:
        os.makedirs(templates_dir, exist_ok=True)
        os.makedirs(static_dir, exist_ok=True)
        print("  - Created directory: _templates, _static")
    except OSError as e:
        print(f"  - Error creating directory _templates/_static: {e}")


def _write_override_template(layout_template_path, layout_content):
    try:
        with open(layout_template_path, "w", encoding="utf-8") as f:
            f.write(layout_content)
        print(
            "  - Created/Updated override template: "
            f"{os.path.basename(layout_template_path)}"
        )
    except Exception as e:
        print(f"  - Error writing override template {layout_template_path}: {e}")


def _update_templates_path_in_conf(new_conf_content, match):
    """Update templates_path variable in conf.py content.

    Tries to add '_templates' at the beginning of existing list
    using ast.literal_eval, con fallback a concatenating di strings.

    Args:
        new_conf_content (str): current content (potentially already modified)
                                del file conf.py.
        match (re.Match): Match object resulting from search pattern
                          for templates_path.

    Returns:
        tuple(str, bool): tuple containing up-to-date content of
                          new_conf_content and a boolean that tells if
                          a modification has been made (True) or not (False).
    """
    conf_updated = False
    current_list_str = match.group(1)
    if "'_templates'" not in current_list_str:
        try:

            current_list = ast.literal_eval(current_list_str)
            if isinstance(current_list, list):
                new_list = ["_templates"] + current_list
                new_list_str_repr = repr(new_list)
                new_conf_content = new_conf_content.replace(
                    match.group(0), f"templates_path = {new_list_str_repr}", 1
                )
                print("  - Prepend '_templates' a templates_path in conf.py")
                conf_updated = True
            else:
                raise ValueError("parsed value for templates_path is not a list")
        except (ValueError, SyntaxError, ImportError):
            print(
                "  - Warning: Fallback per templates_path, uso concatenating strings."
            )
            new_list_str = "['_templates'] + " + current_list_str
            new_conf_content = new_conf_content.replace(
                match.group(0), f"templates_path = {new_list_str}", 1
            )
            conf_updated = True

    return new_conf_content, conf_updated


def _update_static_path_in_conf(new_conf_content, match):
    """Updates la variable html_static_path nel content di conf.py.

    Try to add '_static' alla fine della lista existing
    using ast.literal_eval, con fallback a concatenating di strings.

    Args:
        new_conf_content (str): Il current content (potentially already modified)
                                del file conf.py.
        match (re.Match): Match object match resulting from searching pattern
                          for html_static_path.

    Returns:
        tuple(str, bool): A tuple containing up-to-date content of
                          new_conf_content and a bool that tells if
                          there was a modification (True) or not (False).
    """
    conf_updated = False
    current_list_str = match.group(1)
    if "'_static'" not in current_list_str:
        try:

            current_list = ast.literal_eval(current_list_str)
            if isinstance(current_list, list):
                current_list.append("_static")
                new_list_str_repr = repr(current_list)
                new_conf_content = new_conf_content.replace(
                    match.group(0), f"html_static_path = {new_list_str_repr}", 1
                )
                print("  - Append '_static' a html_static_path in conf.py")
                conf_updated = True
            else:
                raise ValueError("parsed value for html_static_path is not a list")
        except (ValueError, SyntaxError, ImportError):
            print(
                "  - Warning: Fallback per html_static_path, uso "
                "concatenating strings."
            )
            new_list_str = current_list_str.rstrip()[:-1].strip()
            if new_list_str and new_list_str != "[":
                new_list_str += ", '_static']"
            else:
                new_list_str = "['_static']"
            new_conf_content = new_conf_content.replace(
                match.group(0), f"html_static_path = {new_list_str}", 1
            )
            conf_updated = True

    return new_conf_content, conf_updated


def _update_css_files_in_conf(new_conf_content, match, css_file_to_add):
    """Update html_css_files variable in conf.py content.

    Tenta di add il specified CSS file to existing list
    using ast.literal_eval, con fallback a concatenating di strings.

    Args:
        new_conf_content (str): current content (potentially already modified)
                                del file conf.py.
        match (re.Match): match object resulting from pattern search for
                          html_css_files.
        css_file_to_add (str): Il nome del file CSS da add (ex. 'custom.css').

    Returns:
        tuple(str, bool): A tuple containing il up-to-date content of
                          new_conf_content and a bool that tells if
                          a modification occurred (True) or not (False).
    """
    conf_updated = False
    current_list_str = match.group(1)
    if repr(css_file_to_add) not in current_list_str:
        try:

            current_list = ast.literal_eval(current_list_str)
            if isinstance(current_list, list):
                current_list.append(css_file_to_add)
                new_list_str_repr = repr(current_list)
                new_conf_content = new_conf_content.replace(
                    match.group(0), f"html_css_files = {new_list_str_repr}", 1
                )
                print(f"  - Append '{css_file_to_add}' a html_css_files in conf.py")
                conf_updated = True
            else:
                raise ValueError("parsed value for html_css_files is not a list")
        except (ValueError, SyntaxError, ImportError):
            print(
                "  - Warning: Fallback per html_css_files, uso concatenating strings."
            )
            new_list_str = current_list_str.rstrip()[:-1].strip()
            if new_list_str and new_list_str != "[":
                new_list_str += f", '{css_file_to_add}']"
            else:
                new_list_str = f"['{css_file_to_add}']"
            new_conf_content = new_conf_content.replace(
                match.group(0), f"html_css_files = {new_list_str}", 1
            )
            conf_updated = True

    return new_conf_content, conf_updated


def _update_theme_in_conf(conf_content, theme_name):
    """Update or add html_theme variable in conf.py content.

    Args:
        conf_content (str): current content del file conf.py.
        theme_name (str): desired Sphinx theme name.

    Returns:
        tuple(str, bool): A tuple containing conf.py new content
                          and a bool that tells if
                          a modification was made (True) or not (False).
    """
    return conf_content, True
    conf_updated = False
    new_conf_content = conf_content
    theme_pattern = re.compile(r"^\s*html_theme\s*=\s*['\"].*['\"]", re.MULTILINE)
    target_theme_line = f"html_theme = '{theme_name}'"

    match = theme_pattern.search(new_conf_content)
    if match:
        old_theme_line = match.group(0)
        if old_theme_line != target_theme_line:
            new_conf_content = theme_pattern.sub(
                target_theme_line, new_conf_content, count=1
            )
            print(f"  - Updated html_theme -> '{theme_name}' in conf.py")
            conf_updated = True
    else:
        new_conf_content += f"\n{target_theme_line}\n"
        print(f"  - Added html_theme = '{theme_name}' a conf.py")
        conf_updated = True

    return new_conf_content, conf_updated


def apply_devildex_customizations(isolated_source_path, theme_name, banner_text):
    """Apply DevilDex customizations to conf and template, basing on given parameters.

    Args:
        isolated_source_path (str): Path to isolated sources doc directory.
        theme_name (str): Name of Sphinx theme to use.
        banner_text (str): Testo da view nel banner.
    """
    print(
        "\nApplying DevilDex customizations (Theme: "
        f"{theme_name}, Banner: '{banner_text}')..."
    )
    conf_py_path = os.path.join(isolated_source_path, "conf.py")
    templates_dir = os.path.join(isolated_source_path, "_templates")
    static_dir = os.path.join(isolated_source_path, "_static")
    layout_template_path = os.path.join(templates_dir, "layout.html")
    custom_css_path = os.path.join(static_dir, "custom.css")
    _create_template_static(templates_dir, static_dir)
    final_banner = banner_text.format(version=VERSION)
    layout_content = f"""\
    {{% extends "!layout.html" %}}
    {{% block relbar1 %}}
        <div class="devildex-banner">
            {final_banner}
        </div>
        {{{{ super() }}}}
    {{% endblock %}}
    """
    _write_override_template(layout_template_path, layout_content)

    css_content = """\
    /* customized Styles for DevilDex */
    .devildex-banner {
        /* banner Visual Style */
        background-color: #eee;
        padding: 6px 10px; /* horizontal and vertical Padding */
        text-align: center;
        font-size: 0.9em;
        border-bottom: 1px solid #ccc;
        color: #555;
        margin-bottom: 15px; /* Space under the banner after being moved */
        box-sizing: border-box;
        width: 100%; /* Occupies all container width */
    }

    /* Remove eventual padding added previously to body */
    body > .document {
        padding-top: 0;
    }
    """
    _write_custom_css(custom_css_path, css_content)
    try:
        with open(conf_py_path, "r", encoding="utf-8") as f:
            original_conf_content = f.read()
        new_conf_content = original_conf_content

        conf_updated = False

        new_conf_content, theme_updated = _update_theme_in_conf(
            new_conf_content, theme_name
        )
        if theme_updated:
            conf_updated = True

        templates_pattern = re.compile(
            r"^\s*templates_path\s*=\s*(\[.*?\])", re.MULTILINE | re.DOTALL
        )
        match = templates_pattern.search(new_conf_content)
        if match:
            new_conf_content, updated_by_template = _update_templates_path_in_conf(
                new_conf_content, match
            )
            if updated_by_template:
                conf_updated = True

        else:
            new_conf_content += "\ntemplates_path = ['_templates']\n"
            print("  - Added templates_path = ['_templates'] a conf.py")
            conf_updated = True

        static_pattern = re.compile(
            r"^\s*html_static_path\s*=\s*(\[.*?\])", re.MULTILINE | re.DOTALL
        )
        match = static_pattern.search(new_conf_content)
        if match:
            new_conf_content, updated_by_static = _update_static_path_in_conf(
                new_conf_content, match
            )
            if updated_by_static:
                conf_updated = True
        else:
            new_conf_content += "\nhtml_static_path = ['_static']\n"
            print("  - Added html_static_path = ['_static'] a conf.py")
            conf_updated = True

        css_pattern = re.compile(
            r"^\s*html_css_files\s*=\s*(\[.*?\])", re.MULTILINE | re.DOTALL
        )
        match_css = css_pattern.search(new_conf_content)
        css_file_to_add = "custom.css"
        if match_css:
            new_conf_content, updated_by_css_add = _update_css_files_in_conf(
                new_conf_content, match_css, css_file_to_add
            )
            if updated_by_css_add:
                conf_updated = True
        else:
            new_conf_content += f"\nhtml_css_files = ['{css_file_to_add}']\n"
            print(f"  - Added html_css_files = ['{css_file_to_add}'] a conf.py")
            conf_updated = True
        _write_conf(conf_updated, conf_py_path, new_conf_content)
    except Exception as e:
        print(f"  - Error during modifying conf.py {conf_py_path}: {e}")

    print("DevilDex customizations applied.")












def find_doc_source_in_clone(repo_path):
    """
    Identifies the documentation source directory within a cloned repository.
    It does NOT copy any files.

    Args:
        repo_path (str): The local path to the cloned repository.

    Returns:
        str: The path to the documentation source directory (containing conf.py),
             or None if not found.
    """
    print(f"\nSearching for documentation source directory in: {repo_path}")
    potential_doc_dirs = ["docs", "doc", "Doc"]  # Puoi personalizzare questa lista

    doc_source_path = _find_doc_dir_in_repo(repo_path, potential_doc_dirs)

    if not doc_source_path:
        print("No documentation source directory with conf.py found in the clone.")
        return None

    print(f"Documentation source directory identified at: {doc_source_path}")
    return doc_source_path


def _find_doc_dir_in_repo(repo_path, potential_doc_dirs):
    """
    Finds the first potential documentation directory that contains a conf.py file.
    Also checks the repository root if no specific doc directory is found.

    Args:
        repo_path (str): The local path to the cloned repository.
        potential_doc_dirs (list): A list of potential directory names
                                   for documentation (e.g., ["docs", "doc"]).

    Returns:
        str: The path to the documentation source directory (containing conf.py),
             or None if not found.
    """
    for doc_dir_name in potential_doc_dirs:
        current_path = os.path.join(repo_path, doc_dir_name)
        if os.path.isdir(current_path) and os.path.exists(
                os.path.join(current_path, "conf.py")
        ):
            print(
                "Found documentation source directory with conf.py: "
                f"{current_path}"
            )
            return current_path
        if os.path.isdir(current_path):
            print(
                f"Found directory '{current_path}', but no conf.py. "
                "Continuing search..."
            )
    # Fallback: check if conf.py is in the root of the repository
    if os.path.exists(os.path.join(repo_path, "conf.py")):
        print(f"Found conf.py in the repository root: {repo_path}")
        return repo_path

    print(f"Fallback: Searching for conf.py recursively in the entire repository: {repo_path}...")
    for root, dirs, files in os.walk(repo_path):
        # Escludi directory comuni per velocizzare e ridurre rumore
        dirs[:] = [d for d in dirs if d not in [
            '.git', '.hg', '.svn', 'venv', '.venv', 'env', '__pycache__',
            'node_modules', 'build', 'dist', 'docs/_build', 'site'
            # Aggiungi altre directory da escludere se necessario
        ]]
        if "conf.py" in files:
            conf_file_path = os.path.join(root, "conf.py")
            doc_source_dir = root
            print(
                "Found conf.py via full recursive search at: "
                f"{conf_file_path} (source directory: {doc_source_dir})"
            )
            return doc_source_dir

    return None


def _sphinx_run(isolated_source_path, final_output_dir):
    sphinx_build_command = [
        sys.executable,
        "-m",
        "sphinx",
        "-b",
        "html",
        "-W",
        isolated_source_path,
        final_output_dir,
    ]

    print(f"Executing Sphinx: {' '.join(sphinx_build_command)}")
    try:
        result = subprocess.run(
            sphinx_build_command,
            check=True,
            capture_output=True,
            text=True,
            encoding="utf-8",
        )
        print("Build Sphinx completed successfully.")
        if result.stdout:
            print("--- Output Sphinx (stdout) ---")
            print(result.stdout)
            print("-----------------------------")
        if result.stderr:
            print("--- Output Sphinx (stderr) ---")
            print(result.stderr)
            print("-----------------------------")
        return final_output_dir

    except subprocess.CalledProcessError as e:
        print(f"Error durante l' execution di sphinx-build (codice {e.returncode}):")
        print(f"Command: {' '.join(e.cmd)}")
        print("--- Output Sphinx (stdout) ---")
        print(e.stdout)
        print("--- Output Sphinx (stderr) ---")
        print(e.stderr)
        print("-----------------------------")
        return None
    except FileNotFoundError:
        print(f"Error: Unable to execute '{sys.executable} -m sphinx'.")
        print("Be sure che Python sia nel PATH e che Sphinx sia installed")
        print("per questo interpreter Python (`pip install sphinx`).")
        return None
    except Exception as e:
        print(f"Unexpected Error during Sphinx build: {e}")
        return None


def build_sphinx_docs(isolated_source_path, project_slug, version_identifier, original_clone_dir_path):
    """Execute sphinx-build in isolated sources directory.

    Args:
        isolated_source_path (str): Path alla directory containing
            conf.py e i sources.
        project_slug (str): Slug del project per la structure della directory
            di output.
        version_identifier (str): version identifier
            (es. nome branch) per la structure.
        original_clone_dir_path (str): Path alla root del repository
    Returns:
        str: Il path alla directory di output della build HTML, o
            None in caso di failure.
    """
    print("\n--- Starting Build Sphinx ---")
    conf_py_path = os.path.join(isolated_source_path, "conf.py")
    if not os.path.exists(conf_py_path):
        print(
            "Critical Error: conf.py non trovato in "
            f"{isolated_source_path} dopo la copia."
        )
        return None
    if os.path.exists(os.path.join(original_clone_dir_path, "pyproject.toml")) or \
            os.path.exists(os.path.join(original_clone_dir_path, "setup.py")):
        print(
            f"  DEVILDEX INFO: Tentativo di installazione del progetto '{project_slug}' da '{original_clone_dir_path}' in modalità editabile...")
        cmd_install_project = [sys.executable, "-m", "pip", "install", "--disable-pip-version-check",
                               "--no-python-version-warning", "-e", original_clone_dir_path]
        proc_project = subprocess.run(cmd_install_project, capture_output=True, text=True, check=False,
                                      encoding="utf-8")
        if proc_project.returncode != 0:
            print(
                f"    DEVILDEX WARNING: Installazione del progetto '{project_slug}' fallita. Sphinx potrebbe non funzionare correttamente.")
            print(f"      Comando: {' '.join(cmd_install_project)}")
            if proc_project.stdout.strip(): print(f"      Pip STDOUT:\n{proc_project.stdout.strip()}")
            if proc_project.stderr.strip(): print(f"      Pip STDERR:\n{proc_project.stderr.strip()}")
            # Potresti decidere di restituire None qui se questa installazione è critica per TUTTI i progetti
            # return None
        else:
            print(f"    DEVILDEX INFO: Progetto '{project_slug}' installato con successo (o già presente).")
            if proc_project.stdout.strip(): print(f"      Pip STDOUT:\n{proc_project.stdout.strip()}")
    else:
        print(
            f"  DEVILDEX INFO: Nessun pyproject.toml o setup.py trovato in '{original_clone_dir_path}'. Salto installazione progetto in modalità editabile.")
    doc_specific_req_file = os.path.join(isolated_source_path, "requirements.txt")
    if os.path.exists(doc_specific_req_file):
        print(
            f"  DEVILDEX INFO: Tentativo di installazione delle dipendenze specifiche della documentazione da '{doc_specific_req_file}'...")
        cmd_install_doc_reqs = [sys.executable, "-m", "pip", "install", "--disable-pip-version-check",
                                "--no-python-version-warning", "-r", doc_specific_req_file]
        proc_doc_reqs = subprocess.run(cmd_install_doc_reqs, capture_output=True, text=True, check=False,
                                       encoding="utf-8")
        if proc_doc_reqs.returncode != 0:
            print(f"    DEVILDEX WARNING: Installazione delle dipendenze da '{doc_specific_req_file}' fallita.")
            print(f"      Comando: {' '.join(cmd_install_doc_reqs)}")
            if proc_doc_reqs.stdout.strip(): print(f"      Pip STDOUT:\n{proc_doc_reqs.stdout.strip()}")
            if proc_doc_reqs.stderr.strip(): print(f"      Pip STDERR:\n{proc_doc_reqs.stderr.strip()}")
        else:
            print(
                f"    DEVILDEX INFO: Dipendenze da '{doc_specific_req_file}' installate con successo (o già presenti).")
            if proc_doc_reqs.stdout.strip(): print(f"      Pip STDOUT:\n{proc_doc_reqs.stdout.strip()}")
    else:
        print(
            f"  DEVILDEX INFO: Nessun 'requirements.txt' trovato in '{isolated_source_path}'. Salto installazione dipendenze specifiche della documentazione.")
    #

    final_output_dir = os.path.join("../../../docset", project_slug, version_identifier)
    print(f"Directory di output per la build Sphinx HTML: {final_output_dir}")

    try:
        if os.path.exists(final_output_dir):
            print(f"Removing existing output directory: {final_output_dir}")
            shutil.rmtree(final_output_dir)
        os.makedirs(final_output_dir, exist_ok=True)
    except OSError as e:
        print(
            "Error during creating/cleaning output directory "
            f"{final_output_dir}: {e}"
        )
        return None
    result = _sphinx_run(isolated_source_path, final_output_dir)
    return result


def _cleanup(clone_dir_path):
    if os.path.exists(clone_dir_path):
        print(f"\nDeleting repository cloned directory: {clone_dir_path}")
        try:
            shutil.rmtree(clone_dir_path)
            print("Delete completed.")
        except Exception as e:
            print(
                "Error during deleting della repository cloned "
                f"'{clone_dir_path}': {e}"
            )


def _extract_repo_url_branch(api_project_detail_url, project_slug):
    repo_url = None
    default_branch = "main"

    try:
        response = requests.get(api_project_detail_url, timeout=60)
        response.raise_for_status()
        project_data = response.json()
        repo_data = project_data.get("repository")
        if repo_data:
            repo_url = repo_data.get("url")
        default_branch = project_data.get("default_branch", default_branch)

        if not repo_url:
            print(
                "Warning: URL del repository sources non trovato per "
                f"'{project_slug}' using API."
            )
        else:
            print(f"Trovato URL repository: {repo_url}")
            print(f"Branch di default (used come version identifier): {default_branch}")

    except requests.exceptions.RequestException as e:
        print(f"Warning: Error durante la richiesta API: {e}")
        print("Provo a search la repository cloned locally if already exists.")
    return default_branch, repo_url


def download_readthedocs_source_and_build(project_name, project_url, existing_clone_path=None):
    """Get RTD sources, clone, isolate sources doc, executes Sphinx, and cleans-up.

    Args:
        project_name (str): the name of the project.
        project_url (str): the URL of repository of the project.
        existing_clone_path (str, optional): Percorso to a repository già clonato.
                                             Se fornito, la clonazione viene saltata.
                                             Default a None.


    Returns:
        tuple(str, str) or tuple(None, None): Path isolated sources and build HTML path
                                              o (None, None) in case of failure.
    """
    print("--- Process Source Download, Build e Clean-up ---")
    print(f"Analyzing the URL: {project_url}")

    project_slug = project_name
    if not project_slug:
        return None, None

    print(f"project Slug: {project_slug}")
    api_project_detail_url = f"https://readthedocs.org/api/v3/projects/{project_slug}/"
    print(f"Calling API for project details: {api_project_detail_url}")

    default_branch, repo_url = _extract_repo_url_branch(
        api_project_detail_url, project_slug
    )
    base_output_dir = "../../../rtd_source_clones_temp"
    os.makedirs(base_output_dir, exist_ok=True)
    clone_dir_name = f"{project_slug}_repo_{default_branch}"
    clone_dir_path = os.path.join(base_output_dir, clone_dir_name)
    cloned_repo_exists_before = os.path.exists(clone_dir_path)

    if repo_url and not cloned_repo_exists_before:
        print(f"Cloning repository (branch '{default_branch}') in: {clone_dir_path}")
        try:
            subprocess.run(
                [
                    "git",
                    "clone",
                    "--depth",
                    "1",
                    "--branch",
                    default_branch,
                    repo_url,
                    clone_dir_path,
                ],
                check=True,
                capture_output=True,
                text=True,
                encoding="utf-8",
            )
            print("git clone Command executed successfully.")
        except subprocess.CalledProcessError as e:
            print(f"Error during execution of git clone command:\n{e.stderr}")
            return None, None
        except FileNotFoundError:
            print("Error: 'git' command not found. Be sure that Git is installed.")
            return None, None
    elif not cloned_repo_exists_before:
        print(
            "Unable to clone (URL not available or error) e "
            f"expected directory '{clone_dir_path}' doesn't exist."
        )
        return None, None
    else:
        print(f"expected clone Directory '{clone_dir_path}' found locally.")

    isolated_docs_output_dir = "../../../rtd_isolated_doc_sources"
    os.makedirs(isolated_docs_output_dir, exist_ok=True)
    isolated_source_path = find_doc_source_in_clone(
        clone_dir_path
    )

    build_output_path = None
    if isolated_source_path:
        apply_devildex_customizations(
            isolated_source_path, theme_name=custom_theme, banner_text=custom_banner
        )

        build_output_path = build_sphinx_docs(
            isolated_source_path, project_slug, default_branch, clone_dir_path
        )
    else:
        print("Isolate sources Failed, skipping Sphinx build.")

    _cleanup(clone_dir_path)

    if isolated_source_path and build_output_path:
        print(f"\nIsolated source documentation in: {isolated_source_path}")
        print(f"Build HTML Sphinx generata in:    {build_output_path}")
        return isolated_source_path, build_output_path
    if isolated_source_path:
        print(f"\nIsolated Sources documentation in: {isolated_source_path}")
        print("Failed Build Sphinx.")
        return isolated_source_path, None
    print("\nFailed Isolating sources and build Sphinx.")
    return None, None

if __name__ == "__main__":
    print("--- Executing Script v3 (Isolating sources + Build Sphinx + Cleaning) ---")

    isolated_folder, build_folder = download_readthedocs_source_and_build(
        "https://black.readthedocs.io/"
    )

    if build_folder:
        print("\nProcess completed successfully!")
        print(f"  Isolated Sources: {isolated_folder}")
        print(f"  Build HTML:       {build_folder}")
    elif isolated_folder:
        print("\nProcess partially completed.")
        print(f"  Sources isolated: {isolated_folder}")
        print("  Failed Build HTML.")
    else:
        print("\nFailed Process.")
    print("-" * 30)
