import configparser
import os
import re
import shutil
import subprocess
import sys
from urllib.parse import urlparse

import requests
from src.devildex.info import VERSION

config = configparser.ConfigParser()
config_file = "../../../devildex_config.ini"
default_theme = "furo"
default_banner = "Generated by DevilDex"
try:
    if not config.read(config_file, encoding="utf-8"):
        print(
            f"Warning: configuration File  '{config_file}' not found. "
            "Using default values."
        )
        custom_theme = default_theme
        custom_banner = default_banner
    else:
        custom_theme = config.get("customization", "theme_name", fallback=default_theme)
        custom_banner = config.get(
            "customization", "banner_text", fallback=default_banner
        )
        print(
            f"Configuration read from '{config_file}': Theme='{custom_theme}', "
            f"Banner='{custom_banner}'"
        )

except configparser.Error as exc:
    print(
        f"Error reading configuration file '{config_file}': {exc}. "
        "Using default values."
    )
    custom_theme = default_theme
    custom_banner = default_banner


def _write_custom_css(custom_css_path, css_content):
    try:
        with open(custom_css_path, "w", encoding="utf-8") as f:
            f.write(css_content)
        print(
            "  - Created/Updated customized CSS: "
            f"{os.path.basename(custom_css_path)}"
        )
    except Exception as e:
        print(f"  - Error writing customized CSS {custom_css_path}: {e}")


def _write_conf(conf_updated, conf_py_path, new_conf_content):
    if conf_updated:
        with open(conf_py_path, "w", encoding="utf-8") as f:
            f.write(new_conf_content)
        print("  - conf.py rewritten with updates.")
    else:
        print("  - conf.py did not need modifications for customizations.")


def _fallback_css(current_list_str, css_file_to_add, new_conf_content, match):
    new_list_str = current_list_str.rstrip()[:-1].strip()
    if new_list_str and new_list_str != "[":
        new_list_str += f", '{css_file_to_add}']"
    else:
        new_list_str = f"['{css_file_to_add}']"
        new_conf_content = new_conf_content.replace(
            match.group(0), f"html_css_files = {new_list_str}", 1
        )
    conf_updated = True
    return conf_updated


def _create_template_static(templates_dir, static_dir):
    try:
        os.makedirs(templates_dir, exist_ok=True)
        os.makedirs(static_dir, exist_ok=True)
        print("  - Created directory: _templates, _static")
    except OSError as e:
        print(f"  - Error creating directory _templates/_static: {e}")


def _write_override_template(layout_template_path, layout_content):
    try:
        with open(layout_template_path, "w", encoding="utf-8") as f:
            f.write(layout_content)
        print(
            "  - Created/Updated override template: "
            f"{os.path.basename(layout_template_path)}"
        )
    except Exception as e:
        print(f"  - Error writing override template {layout_template_path}: {e}")


def _update_templates_path_in_conf(new_conf_content, match):
    """Update templates_path variable in conf.py content.

    Tries to add '_templates' at the beginning of existing list
    using ast.literal_eval, con fallback a concatenating di strings.

    Args:
        new_conf_content (str): current content (potentially already modified)
                                del file conf.py.
        match (re.Match): Match object resulting from search pattern
                          for templates_path.

    Returns:
        tuple(str, bool): tuple containing up-to-date content of
                          new_conf_content and a boolean that tells if
                          a modification has been made (True) or not (False).
    """
    conf_updated = False
    current_list_str = match.group(1)
    if "'_templates'" not in current_list_str:
        try:
            import ast

            current_list = ast.literal_eval(current_list_str)
            if isinstance(current_list, list):
                new_list = ["_templates"] + current_list
                new_list_str_repr = repr(new_list)
                new_conf_content = new_conf_content.replace(
                    match.group(0), f"templates_path = {new_list_str_repr}", 1
                )
                print("  - Prepend '_templates' a templates_path in conf.py")
                conf_updated = True
            else:
                raise ValueError("parsed value for templates_path is not a list")
        except (ValueError, SyntaxError, ImportError):
            print(
                "  - Warning: Fallback per templates_path, uso concatenating strings."
            )
            new_list_str = "['_templates'] + " + current_list_str
            new_conf_content = new_conf_content.replace(
                match.group(0), f"templates_path = {new_list_str}", 1
            )
            conf_updated = True

    return new_conf_content, conf_updated


def _update_static_path_in_conf(new_conf_content, match):
    """Updates la variable html_static_path nel content di conf.py.

    Try to add '_static' alla fine della lista existing
    using ast.literal_eval, con fallback a concatenating di strings.

    Args:
        new_conf_content (str): Il current content (potentially already modified)
                                del file conf.py.
        match (re.Match): Match object match resulting from searching pattern
                          for html_static_path.

    Returns:
        tuple(str, bool): A tuple containing up-to-date content of
                          new_conf_content and a bool that tells if
                          there was a modification (True) or not (False).
    """
    conf_updated = False
    current_list_str = match.group(1)
    if "'_static'" not in current_list_str:
        try:
            import ast

            current_list = ast.literal_eval(current_list_str)
            if isinstance(current_list, list):
                current_list.append("_static")
                new_list_str_repr = repr(current_list)
                new_conf_content = new_conf_content.replace(
                    match.group(0), f"html_static_path = {new_list_str_repr}", 1
                )
                print("  - Append '_static' a html_static_path in conf.py")
                conf_updated = True
            else:
                raise ValueError(
                    "parsed value for html_static_path is not a list"
                )
        except (ValueError, SyntaxError, ImportError):
            print(
                "  - Warning: Fallback per html_static_path, uso "
                "concatenating strings."
            )
            new_list_str = current_list_str.rstrip()[:-1].strip()
            if new_list_str and new_list_str != "[":
                new_list_str += ", '_static']"
            else:
                new_list_str = "['_static']"
            new_conf_content = new_conf_content.replace(
                match.group(0), f"html_static_path = {new_list_str}", 1
            )
            conf_updated = True

    return new_conf_content, conf_updated


def _update_css_files_in_conf(new_conf_content, match, css_file_to_add):
    """Update html_css_files variable in conf.py content.

    Tenta di add il specified CSS file to existing list
    using ast.literal_eval, con fallback a concatenating di strings.

    Args:
        new_conf_content (str): current content (potentially already modified)
                                del file conf.py.
        match (re.Match): match object resulting from pattern search for
                          html_css_files.
        css_file_to_add (str): Il nome del file CSS da add (ex. 'custom.css').

    Returns:
        tuple(str, bool): A tuple containing il up-to-date content of
                          new_conf_content and a bool that tells if
                          a modification occurred (True) or not (False).
    """
    conf_updated = False
    current_list_str = match.group(1)
    if repr(css_file_to_add) not in current_list_str:
        try:
            import ast

            current_list = ast.literal_eval(current_list_str)
            if isinstance(current_list, list):
                current_list.append(css_file_to_add)
                new_list_str_repr = repr(current_list)
                new_conf_content = new_conf_content.replace(
                    match.group(0), f"html_css_files = {new_list_str_repr}", 1
                )
                print(f"  - Append '{css_file_to_add}' a html_css_files in conf.py")
                conf_updated = True
            else:
                raise ValueError("parsed value for html_css_files is not a list")
        except (ValueError, SyntaxError, ImportError):
            print(
                "  - Warning: Fallback per html_css_files, uso concatenating strings."
            )
            new_list_str = current_list_str.rstrip()[:-1].strip()
            if new_list_str and new_list_str != "[":
                new_list_str += f", '{css_file_to_add}']"
            else:
                new_list_str = f"['{css_file_to_add}']"
            new_conf_content = new_conf_content.replace(
                match.group(0), f"html_css_files = {new_list_str}", 1
            )
            conf_updated = True

    return new_conf_content, conf_updated


def _update_theme_in_conf(conf_content, theme_name):
    """Update or add html_theme variable in conf.py content.

    Args:
        conf_content (str): current content del file conf.py.
        theme_name (str): desired Sphinx theme name.

    Returns:
        tuple(str, bool): A tuple containing conf.py new content
                          and a bool that tells if
                          a modification was made (True) or not (False).
    """
    conf_updated = False
    new_conf_content = conf_content
    theme_pattern = re.compile(r"^\s*html_theme\s*=\s*['\"].*['\"]", re.MULTILINE)
    target_theme_line = f"html_theme = '{theme_name}'"

    match = theme_pattern.search(new_conf_content)
    if match:
        old_theme_line = match.group(0)
        if old_theme_line != target_theme_line:
            new_conf_content = theme_pattern.sub(
                target_theme_line, new_conf_content, count=1
            )
            print(f"  - Updated html_theme -> '{theme_name}' in conf.py")
            conf_updated = True
    else:
        new_conf_content += f"\n{target_theme_line}\n"
        print(f"  - Added html_theme = '{theme_name}' a conf.py")
        conf_updated = True

    return new_conf_content, conf_updated


def apply_devildex_customizations(isolated_source_path, theme_name, banner_text):
    """Apply DevilDex customizations to configuration and Sphinx template,
    basing sui given parameters.

    Args:
        isolated_source_path (str): Path to isolated sources doc directory.
        theme_name (str): Name of Sphinx theme to use.
        banner_text (str): Testo da view nel banner.
    """
    print(
        "\nApplying DevilDex customizations (Theme: "
        f"{theme_name}, Banner: '{banner_text}')..."
    )
    conf_py_path = os.path.join(isolated_source_path, "conf.py")
    templates_dir = os.path.join(isolated_source_path, "_templates")
    static_dir = os.path.join(isolated_source_path, "_static")
    layout_template_path = os.path.join(templates_dir, "layout.html")
    custom_css_path = os.path.join(static_dir, "custom.css")
    _create_template_static(templates_dir, static_dir)
    final_banner = banner_text.format(version=VERSION)
    layout_content = f"""\
    {{% extends "!layout.html" %}}
    {{% block relbar1 %}}
        <div class="devildex-banner">
            {final_banner}
        </div>
        {{{{ super() }}}}
    {{% endblock %}}
    """
    _write_override_template(layout_template_path, layout_content)

    css_content = """\
    /* customized Styles for DevilDex */
    .devildex-banner {
        /* banner Visual Style */
        background-color: #eee;
        padding: 6px 10px; /* horizontal and vertical Padding */
        text-align: center;
        font-size: 0.9em;
        border-bottom: 1px solid #ccc;
        color: #555;
        margin-bottom: 15px; /* Space under the banner after being moved */
        box-sizing: border-box;
        width: 100%; /* Occupies all container width */
    }

    /* Remove eventual padding added previously to body */
    body > .document {
        padding-top: 0;
    }
    """
    _write_custom_css(custom_css_path, css_content)
    try:
        with open(conf_py_path, "r", encoding="utf-8") as f:
            original_conf_content = f.read()
        new_conf_content = original_conf_content

        conf_updated = False

        new_conf_content, theme_updated = _update_theme_in_conf(
            new_conf_content, theme_name
        )
        if theme_updated:
            conf_updated = True

        templates_pattern = re.compile(
            r"^\s*templates_path\s*=\s*(\[.*?\])", re.MULTILINE | re.DOTALL
        )
        match = templates_pattern.search(new_conf_content)
        if match:
            new_conf_content, updated_by_template = _update_templates_path_in_conf(
                new_conf_content, match
            )
            if updated_by_template:
                conf_updated = True

        else:
            new_conf_content += "\ntemplates_path = ['_templates']\n"
            print("  - Added templates_path = ['_templates'] a conf.py")
            conf_updated = True

        static_pattern = re.compile(
            r"^\s*html_static_path\s*=\s*(\[.*?\])", re.MULTILINE | re.DOTALL
        )
        match = static_pattern.search(new_conf_content)
        if match:
            new_conf_content, updated_by_static = _update_static_path_in_conf(
                new_conf_content, match
            )
            if updated_by_static:
                conf_updated = True
        else:
            new_conf_content += "\nhtml_static_path = ['_static']\n"
            print("  - Added html_static_path = ['_static'] a conf.py")
            conf_updated = True

        css_pattern = re.compile(
            r"^\s*html_css_files\s*=\s*(\[.*?\])", re.MULTILINE | re.DOTALL
        )
        match = css_pattern.search(new_conf_content)
        css_file_to_add = "custom.css"
        if match:
            new_conf_content, updated_by_static = _update_static_path_in_conf(
                new_conf_content, match
            )
            if updated_by_static:
                conf_updated = True
        else:
            new_conf_content += f"\nhtml_css_files = ['{css_file_to_add}']\n"
            print(f"  - Added html_css_files = ['{css_file_to_add}'] a conf.py")
            conf_updated = True
        _write_conf(conf_updated, conf_py_path, new_conf_content)
    except Exception as e:
        print(f"  - Error during modifying conf.py {conf_py_path}: {e}")

    print("DevilDex customizations applied.")


def patch_include_directives(doc_source_path):
    """Patches relative include directives in specific Markdown files.
    Changes `{include} ../FILE` to `{include} /FILE` (absolute from source dir).
    """
    print(f"\nPatching include directives in {doc_source_path}...")
    files_to_patch = {
        "authors.md": "../AUTHORS.md",
        "change_log.md": "../CHANGES.md",
        "license.md": "../LICENSE",
    }
    patched_count = 0

    for md_file, old_include_path in files_to_patch.items():
        file_path = os.path.join(doc_source_path, md_file)
        if os.path.exists(file_path):
            try:
                with open(file_path, "r+", encoding="utf-8") as f:
                    content = f.read()
                    old_directive = f"{{include}} {old_include_path}"
                    new_filename = os.path.basename(old_include_path)
                    new_directive = f"{{include}} /{new_filename}"

                    if old_directive in content:
                        new_content = content.replace(old_directive, new_directive)
                        f.seek(0)
                        f.write(new_content)
                        f.truncate()
                        print(
                            f"  - Patched {md_file}: '{old_directive}' -> "
                            f"'{new_directive}'"
                        )
                        patched_count += 1
                    else:
                        print(
                            f"  - Directive '{old_directive}' not found in "
                            f"{md_file}, no patch."
                        )

            except Exception as patch_err:
                print(f"  - Error during patching of {md_file}: {patch_err}")
        else:
            print(f"  - File {md_file} not found in {doc_source_path}, skipping patch.")

    if patched_count > 0:
        print("Patching completed.")
    else:
        print("No file patched (or directive not found).")


def _find_dir(repo_path, potential_doc_dirs):
    found_doc_path = None
    for doc_dir_name in potential_doc_dirs:
        current_path = os.path.join(repo_path, doc_dir_name)
        if os.path.isdir(current_path) and os.path.exists(
            os.path.join(current_path, "conf.py")
        ):
            found_doc_path = current_path
            print(
                "Found directory sources documentation con conf.py: "
                f"{found_doc_path}"
            )
            break
        elif os.path.isdir(current_path):
            print(
                f"Found directory '{current_path}', ma senza conf.py. "
                "Continuo la ricerca..."
            )
    return found_doc_path


def _clean_isolated_doc_path(isolated_doc_path):
    if os.path.exists(isolated_doc_path):
        print(
            "Remove existing isolated sources directory  "
            f": '{isolated_doc_path}'"
        )
        try:
            shutil.rmtree(isolated_doc_path)
        except Exception as e:
            print(f"Error during removing existing directory : {e}")
            return None
    return True


def _copy_src_doc(repo_path, isolated_doc_path, found_doc_path):
    if (
        os.path.exists(os.path.join(found_doc_path, "conf.py"))
        or found_doc_path == repo_path
    ):
        shutil.copytree(
            found_doc_path, isolated_doc_path, ignore=shutil.ignore_patterns(".git")
        )
        print("Copy of main sources directory completed.")
    else:
        print(
            f"Error: conf.py non trovato nel selected path '{found_doc_path}' "
            "durante la copia."
        )
        return None
    return True


def _copy_common_files(common_root_files, repo_path, isolated_doc_path):
    copied_root_files_count = 0
    for filename in common_root_files:
        src_file = os.path.join(repo_path, filename)
        dst_file = os.path.join(isolated_doc_path, filename)
        if os.path.exists(src_file):
            try:
                shutil.copy2(src_file, dst_file)
                print(f"  - Copied: {filename}")
                copied_root_files_count += 1
            except Exception as copy_err:
                print(f"  - Error durante la copia di {filename}: {copy_err}")
        else:
            print(
                f"  - File root '{filename}' non trovato in {repo_path}, non copied."
            )
    return copied_root_files_count


def find_and_copy_doc_source(repo_path, output_base_dir, project_slug):
    """Cerca le directory sources della documentation inside di una
    repository cloned
    e copia la prima found in una folder di output dedicated, including
    specified files in root.

    Args:
        repo_path (str): Il path locale alla repository cloned.
        output_base_dir (str): La directory base dove save i isolated sources.
        project_slug (str): Lo slug del project, used per name
            output folder.

    Returns:
        str: Il path alla directory dei sources di documentation isolated,
            o None se non found/copied.
    """
    print(f"\nSearching directory documentation sources in: {repo_path}")

    potential_doc_dirs = ["docs", "doc", "Doc"]

    found_doc_path = _find_dir(repo_path, potential_doc_dirs)

    if not found_doc_path and os.path.exists(os.path.join(repo_path, "conf.py")):
        found_doc_path = repo_path
        print(f"Trovato conf.py nella root della repository: {found_doc_path}")

    if not found_doc_path:
        print("No sources documentation directory with conf.py found.")
        return None

    isolated_doc_dir_name = f"{project_slug}_doc_source"
    isolated_doc_path = os.path.join(output_base_dir, isolated_doc_dir_name)

    if not _clean_isolated_doc_path(isolated_doc_path):
        return None

    print(
        f"Copying i sources della documentation da '{found_doc_path}' a "
        f"'{isolated_doc_path}'"
    )
    try:
        if not _copy_src_doc(repo_path, isolated_doc_path, found_doc_path):
            return None
        common_root_files = ["AUTHORS.md", "CHANGES.md", "LICENSE"]
        print("Cerco e copying file comuni dalla root del repository...")
        copied_root_files_count = _copy_common_files(
            common_root_files, repo_path, isolated_doc_path
        )
        if copied_root_files_count == len(common_root_files):
            print(
                f"Copied {copied_root_files_count}  required additives "
                "files from root."
            )
        elif copied_root_files_count > 0:
            print(
                f"Copied {copied_root_files_count}/{len(common_root_files)} "
                "additional files required dalla root."
            )
        else:
            print(
                "Warning: No additive common file required found "
                "or copied from root."
            )

        return isolated_doc_path

    except Exception as e:
        print(f"Error during copying sources documentation: {e}")
        return None


def _sphinx_run(isolated_source_path, final_output_dir):
    sphinx_build_command = [
        sys.executable,
        "-m",
        "sphinx",
        "-b",
        "html",
        "-W",
        isolated_source_path,
        final_output_dir,
    ]

    print(f"Executing Sphinx: {' '.join(sphinx_build_command)}")
    try:
        result = subprocess.run(
            sphinx_build_command,
            check=True,
            capture_output=True,
            text=True,
            encoding="utf-8",
        )
        print("Build Sphinx completed successfully.")
        if result.stdout:
            print("--- Output Sphinx (stdout) ---")
            print(result.stdout)
            print("-----------------------------")
        if result.stderr:
            print("--- Output Sphinx (stderr) ---")
            print(result.stderr)
            print("-----------------------------")
        return final_output_dir

    except subprocess.CalledProcessError as e:
        print(f"Error durante l' execution di sphinx-build (codice {e.returncode}):")
        print(f"Command: {' '.join(e.cmd)}")
        print("--- Output Sphinx (stdout) ---")
        print(e.stdout)
        print("--- Output Sphinx (stderr) ---")
        print(e.stderr)
        print("-----------------------------")
        return None
    except FileNotFoundError:
        print(f"Error: Unable to execute '{sys.executable} -m sphinx'.")
        print("Be sure che Python sia nel PATH e che Sphinx sia installed")
        print("per questo interpreter Python (`pip install sphinx`).")
        return None
    except Exception as e:
        print(f"Unexpected Error during Sphinx build: {e}")
        return None


def build_sphinx_docs(isolated_source_path, project_slug, version_identifier):
    """
    Execute sphinx-build in isolated sources directory.

    Args:
        isolated_source_path (str): Path alla directory containing
            conf.py e i sources.
        project_slug (str): Slug del project per la structure della directory
            di output.
        version_identifier (str): version identifier
            (es. nome branch) per la structure.

    Returns:
        str: Il path alla directory di output della build HTML, o
            None in caso di failure.
    """
    print("\n--- Starting Build Sphinx ---")
    conf_py_path = os.path.join(isolated_source_path, "conf.py")
    if not os.path.exists(conf_py_path):
        print(
            "Critical Error: conf.py non trovato in "
            f"{isolated_source_path} dopo la copia."
        )
        return None

    final_output_dir = os.path.join("../../../docset", project_slug, version_identifier)
    print(f"Directory di output per la build Sphinx HTML: {final_output_dir}")

    try:
        if os.path.exists(final_output_dir):
            print(f"Removing existing output directory: {final_output_dir}")
            shutil.rmtree(final_output_dir)
        os.makedirs(final_output_dir, exist_ok=True)
    except OSError as e:
        print(
            "Error during creating/cleaning output directory "
            f"{final_output_dir}: {e}"
        )
        return None
    result = _sphinx_run(isolated_source_path, final_output_dir)
    return result


def _cleanup(clone_dir_path):
    if os.path.exists(clone_dir_path):
        print(f"\nDeleting repository cloned directory: {clone_dir_path}")
        try:
            shutil.rmtree(clone_dir_path)
            print("Delete completed.")
        except Exception as e:
            print(
                "Error during deleting della repository cloned "
                f"'{clone_dir_path}': {e}"
            )


def _extract_slug(rtd_url):
    parsed_url = urlparse(rtd_url)
    path_parts = [part for part in parsed_url.path.split("/") if part]
    project_slug = parsed_url.hostname.split(".")[0]
    if project_slug == "readthedocs" and path_parts:
        project_slug = path_parts[0]
    elif not project_slug or project_slug == "readthedocs":
        if path_parts:
            project_slug = path_parts[0]
        else:
            print("Error: Unable to get project slug project from URL.")
            return None, None
    return project_slug


def _extract_repo_url_branch(api_project_detail_url, project_slug):
    repo_url = None
    default_branch = "main"

    try:
        response = requests.get(api_project_detail_url)
        response.raise_for_status()
        project_data = response.json()
        repo_data = project_data.get("repository")
        if repo_data:
            repo_url = repo_data.get("url")
        default_branch = project_data.get("default_branch", default_branch)

        if not repo_url:
            print(
                "Warning: URL del repository sources non trovato per "
                f"'{project_slug}' using API."
            )
        else:
            print(f"Trovato URL repository: {repo_url}")
            print(
                f"Branch di default (used come version identifier): {default_branch}"
            )

    except requests.exceptions.RequestException as e:
        print(f"Warning: Error durante la richiesta API: {e}")
        print("Provo a search la repository cloned locally if already exists.")
    return default_branch, repo_url


def download_readthedocs_source_and_build(rtd_url):
    """
    Get RTD sources, clone, isolate sources doc, executes Sphinx, and cleans-up.

    Args:
        rtd_url (str): the URL base del project Read the Docs
            (es. https://black.readthedocs.io/).

    Returns:
        tuple(str, str) or tuple(None, None): Path isolated sources and build HTML path
                                              o (None, None) in case of failure.
    """
    print("--- Process Source Download, Build e Clean-up ---")
    print(f"Analyzing the URL: {rtd_url}")

    project_slug = _extract_slug(rtd_url)
    if not project_slug:
        return None, None

    print(f"project Slug: {project_slug}")
    api_project_detail_url = f"https://readthedocs.org/api/v3/projects/{project_slug}/"
    print(f"Calling API for project details: {api_project_detail_url}")

    default_branch, repo_url = _extract_repo_url_branch(
        api_project_detail_url, project_slug
    )
    base_output_dir = "../../../rtd_source_clones_temp"
    os.makedirs(base_output_dir, exist_ok=True)
    clone_dir_name = f"{project_slug}_repo_{default_branch}"
    clone_dir_path = os.path.join(base_output_dir, clone_dir_name)
    cloned_repo_exists_before = os.path.exists(clone_dir_path)

    if repo_url and not cloned_repo_exists_before:
        print(f"Cloning repository (branch '{default_branch}') in: {clone_dir_path}")
        try:
            subprocess.run(
                [
                    "git",
                    "clone",
                    "--depth",
                    "1",
                    "--branch",
                    default_branch,
                    repo_url,
                    clone_dir_path,
                ],
                check=True,
                capture_output=True,
                text=True,
                encoding="utf-8",
            )
            print("git clone Command executed successfully.")
        except subprocess.CalledProcessError as e:
            print(f"Error during execution of git clone command:\n{e.stderr}")
            return None, None
        except FileNotFoundError:
            print(
                "Error: 'git' command not found. Be sure"
                " that Git is installed."
            )
            return None, None
    elif not cloned_repo_exists_before:
        print(
            "Unable to clone (URL not available or error) e "
            f"expected directory '{clone_dir_path}' doesn't exist."
        )
        return None, None
    else:
        print(f"expected clone Directory '{clone_dir_path}' found locally.")

    isolated_docs_output_dir = "../../../rtd_isolated_doc_sources"
    os.makedirs(isolated_docs_output_dir, exist_ok=True)
    isolated_source_path = find_and_copy_doc_source(
        clone_dir_path, isolated_docs_output_dir, project_slug
    )

    build_output_path = None
    if isolated_source_path:
        patch_include_directives(isolated_source_path)
        apply_devildex_customizations(
            isolated_source_path, theme_name=custom_theme, banner_text=custom_banner
        )

        build_output_path = build_sphinx_docs(
            isolated_source_path, project_slug, default_branch
        )
    else:
        print("Isolate sources Failed, skipping Sphinx build.")

    _cleanup(clone_dir_path)

    if isolated_source_path and build_output_path:
        print(f"\nIsolated source documentation in: {isolated_source_path}")
        print(f"Build HTML Sphinx generata in:    {build_output_path}")
        return isolated_source_path, build_output_path
    elif isolated_source_path:
        print(f"\nIsolated Sources documentation in: {isolated_source_path}")
        print("Failed Build Sphinx.")
        return isolated_source_path, None
    else:
        print("\nFailed Isolating sources and build Sphinx.")
        return None, None


print("--- Executing Script v3 (Isolating sources + Build Sphinx + Cleaning) ---")

isolated_folder, build_folder = download_readthedocs_source_and_build(
    "https://black.readthedocs.io/"
)

if build_folder:
    print("\nProcess completed successfully!")
    print(f"  Isolated Sources: {isolated_folder}")
    print(f"  Build HTML:       {build_folder}")
elif isolated_folder:
    print("\nProcess partially completed.")
    print(f"  Sources isolated: {isolated_folder}")
    print("  Failed Build HTML.")
else:
    print("\nFailed Process.")
print("-" * 30)
